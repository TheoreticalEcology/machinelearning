{
  "hash": "077d63b8daff3cf8bda8759f31cf3139",
  "result": {
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n# Artificial Neural Networks\n\nArtificial neural networks are biologically inspired, the idea is that inputs are processed by weights, the neurons, the signals then accumulate at hidden nodes (axioms), and only if the sum of activations of several neurons exceed a certain threshold, the signal will be passed on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cito)\n```\n:::\n\n\ncito allows us to fit fully-connected neural networks within one line of code. When we come to other tasks such as image recognition we have to use frameworks with higher flexibility such as keras or torch.\n\nNeural networks are harder to optimize (hey are optimized via backpropagation and gradient descent) and a few hyperparameters that control the optimization should be familiar:\n\n+----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+\n| Hyperparameter | Meaning                                                                                                                                                                                                       | Range                     |\n+================+===============================================================================================================================================================================================================+===========================+\n| learning rate  | the step size of the parameter updating in the iterative optimization routine, if too high, the optimizer will step over good local optima, if too small, the optimizer will be stuck in a bad local optima   | \\[0.00001, 0.5\\]          |\n+----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+\n| batch size     | NNs are optimized via stochastic gradient descent, i.e. only a batch of the data is used to update the parameters at a time                                                                                   | Depends on the data:      |\n|                |                                                                                                                                                                                                               |                           |\n|                |                                                                                                                                                                                                               | 10-250                    |\n+----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+\n| epoch          | the data is fed into the optimization in batches, once the entire data set has been used in the optimization, the epoch is complete (so e.g. n = 100, batch size = 20, it takes 5 steps to complete an epoch) | 100+ (use early stopping) |\n+----------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+\n\nExample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = airquality[complete.cases(airquality),] # DNN cannot handle NAs!\ndata = scale(data)\n\nmodel = dnn(Ozone~., \n            hidden = c(10L, 10L), # Architecture, number of hidden layers and nodes in each layer\n            activation = c(\"selu\", \"selu\"), # activation functions for the specific hidden layer\n            loss = \"mse\", lr = 0.01, data = data, epochs = 150L, verbose = FALSE)\n```\n\n::: {.cell-output-display}\n![](B3-NeuralNetworks_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(model)\n```\n\n::: {.cell-output-display}\n![](B3-NeuralNetworks_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSummary of Deep Neural Network Model\n\nFeature Importance:\n  variable importance_1\n1  Solar.R     1.282251\n2     Wind     2.325529\n3     Temp     3.393150\n4    Month     1.069392\n5      Day     1.101882\n\nAverage Conditional Effects:\n         Response_1\nSolar.R  0.15587253\nWind    -0.35045646\nTemp     0.49864064\nMonth   -0.06872585\nDay      0.08320668\n\nStandard Deviation of Conditional Effects:\n        Response_1\nSolar.R 0.11932626\nWind    0.20344973\nTemp    0.23440619\nMonth   0.06186247\nDay     0.05851743\n```\n:::\n:::\n\n\nThe architecture of the NN can be specified by the `hidden` argument, it is a vector where the length corresponds to the number of hidden layers and value of entry to the number of hidden neurons in each layer (and the same applies for the `activation` argument that specifies the activation functions in the hidden layers). It is hard to make recommendations about the architecture, a kind of general rule is that the width of the hidden layers is more important than the depth of the NN.\n\nThe loss function has to be adjusted to the response type:\n\n+---------------------------+---------------------------------------+--------------------------------------------------+\n| Loss                      | Type                                  | Example                                          |\n+===========================+=======================================+==================================================+\n| mse (mean squared error)  | Regression                            | Numeric values                                   |\n+---------------------------+---------------------------------------+--------------------------------------------------+\n| mae (mean absolute error) | Regression                            | Numeric values, often used for skewed data       |\n+---------------------------+---------------------------------------+--------------------------------------------------+\n| softmax                   | Classification, multi-label           | Species                                          |\n+---------------------------+---------------------------------------+--------------------------------------------------+\n| cross-entropy             | Classification, binary or multi-class | Survived/non-survived, Multi-species/communities |\n+---------------------------+---------------------------------------+--------------------------------------------------+\n| binomial                  | Classification, binary or multi-class | Binomial likelihood                              |\n+---------------------------+---------------------------------------+--------------------------------------------------+\n| poisson                   | Regression                            | Count data                                       |\n+---------------------------+---------------------------------------+--------------------------------------------------+\n\n::: callout-caution\n## Importance of the learning rate\n\ncito visualizes the training (see graphic). The reason for this is that the training can easily fail if the learning rate (lr) is poorly chosen. If the lr is too high, the optimizer \"jumps\" over good local optima, while it gets stuck in local optima if the lr is too small:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = dnn(Ozone~., \n            hidden = c(10L, 10L), \n            activation = c(\"selu\", \"selu\"), \n            loss = \"mse\", lr = 0.4, data = data, epochs = 150L, verbose = FALSE)\n```\n:::\n\n\nIf too high, the training will either directly fail (because the loss jumps to infinity) or the loss will be very wiggly and doesn't decrease over the number of epochs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = dnn(Ozone~., \n            hidden = c(10L, 10L), \n            activation = c(\"selu\", \"selu\"), \n            loss = \"mse\", lr = 0.0001, data = data, epochs = 150L, verbose = FALSE)\n```\n\n::: {.cell-output-display}\n![](B3-NeuralNetworks_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nIf too low, the loss will be very wiggly but doesn't decrease.\n:::\n\n::: callout-note\n## Learning rate scheduler\n\nAdjusting / reducing the learning rate during training is a common approach in neural networks. The idea is to start with a larger learning rate and then steadily decrease it during training (either systematically or based on specific properties):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = dnn(Ozone~., \n            hidden = c(10L, 10L), \n            activation = c(\"selu\", \"selu\"), \n            loss = \"mse\", \n            lr = 0.1,\n            lr_scheduler = config_lr_scheduler(\"step\", step_size = 30, gamma = 0.1),\n            # reduce learning all 30 epochs (new lr = 0.1* old lr)\n            data = data, epochs = 150L, verbose = FALSE)\n```\n\n::: {.cell-output-display}\n![](B3-NeuralNetworks_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n:::\n\n## Regularization\n\nWe can use $\\lambda$ and $\\alpha$ to set L1 and L2 regularization on the weights in our NN:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = dnn(Ozone~., \n            hidden = c(10L, 10L), \n            activation = c(\"selu\", \"selu\"), \n            loss = \"mse\", \n            lr = 0.01,\n            lambda = 0.01, # regularization strength\n            alpha = 0.5,\n            lr_scheduler = config_lr_scheduler(\"step\", step_size = 30, gamma = 0.1),\n            # reduce learning all 30 epochs (new lr = 0.1* old lr)\n            data = data, epochs = 150L, verbose = FALSE)\n```\n\n::: {.cell-output-display}\n![](B3-NeuralNetworks_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSummary of Deep Neural Network Model\n\nFeature Importance:\n  variable importance_1\n1  Solar.R     1.219006\n2     Wind     2.238859\n3     Temp     3.039264\n4    Month     1.085431\n5      Day     1.043072\n\nAverage Conditional Effects:\n         Response_1\nSolar.R  0.17430782\nWind    -0.38153394\nTemp     0.50262698\nMonth   -0.11946131\nDay      0.08148744\n\nStandard Deviation of Conditional Effects:\n        Response_1\nSolar.R 0.06171715\nWind    0.13890689\nTemp    0.18629979\nMonth   0.07913466\nDay     0.03143301\n```\n:::\n:::\n\n\nBe careful that you don't accidentally set all weights to 0 because of a too high regularization. We check the weights of the first layer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfields::image.plot(coef(model)[[1]][[1]]) # weights of the first layer\n```\n\n::: {.cell-output-display}\n![](B3-NeuralNetworks_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Exercise\n\n::: {.callout-warning}\n#### Question: Hyperparameter tuning - Titanic dataset\n\nTune architecture\n\n-   Play around with the architecture and try to improve the AUC on the submission server\n\nBonus:\n\n-   Tune the learning rate and the regularization for the titanic dataset! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(missRanger)\ndata(titanic_ml)\ndata = titanic_ml\ndata = \n  data %>% select(survived, sex, age, fare, pclass)\ndata[,-1] = missRanger(data[,-1], verbose = 0)\n\ndata_sub =\n  data %>%\n    mutate(age = scales::rescale(age, c(0, 1)),\n           fare = scales::rescale(fare, c(0, 1))) %>%\n    mutate(sex = as.integer(sex) - 1L,\n           pclass = as.integer(pclass - 1L))\ndata_new = data_sub[is.na(data_sub$survived),] # for which we want to make predictions at the end\ndata_obs = data_sub[!is.na(data_sub$survived),] # data with known response\n\n\nmodel = dnn(survived~., \n          hidden = c(10L, 10L), # change\n          activation = c(\"selu\", \"selu\"), # change\n          loss = \"binomial\", \n          lr = 0.05, #change\n          validation = 0.2,\n          lambda = 0.001, # change\n          alpha = 0.1, # change\n          lr_scheduler = config_lr_scheduler(\"reduce_on_plateau\", patience = 10, factor = 0.9),\n          data = data_obs, epochs = 40L, verbose = TRUE, plot= TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLoss at epoch 1: training: 0.643, validation: 0.592, lr: 0.05000\n```\n:::\n\n::: {.cell-output-display}\n![](B3-NeuralNetworks_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nLoss at epoch 2: training: 0.632, validation: 0.782, lr: 0.05000\nLoss at epoch 3: training: 0.591, validation: 0.517, lr: 0.05000\nLoss at epoch 4: training: 0.609, validation: 0.618, lr: 0.05000\nLoss at epoch 5: training: 0.590, validation: 0.504, lr: 0.05000\nLoss at epoch 6: training: 0.609, validation: 0.737, lr: 0.05000\nLoss at epoch 7: training: 0.602, validation: 0.683, lr: 0.05000\nLoss at epoch 8: training: 0.569, validation: 0.567, lr: 0.05000\nLoss at epoch 9: training: 0.566, validation: 0.639, lr: 0.05000\nLoss at epoch 10: training: 0.593, validation: 0.831, lr: 0.05000\nLoss at epoch 11: training: 0.595, validation: 0.482, lr: 0.05000\nLoss at epoch 12: training: 0.586, validation: 0.481, lr: 0.05000\nLoss at epoch 13: training: 0.606, validation: 0.513, lr: 0.05000\nLoss at epoch 14: training: 0.552, validation: 0.450, lr: 0.05000\nLoss at epoch 15: training: 0.539, validation: 0.557, lr: 0.05000\nLoss at epoch 16: training: 0.528, validation: 0.417, lr: 0.05000\nLoss at epoch 17: training: 0.503, validation: 0.441, lr: 0.05000\nLoss at epoch 18: training: 0.495, validation: 0.403, lr: 0.05000\nLoss at epoch 19: training: 0.556, validation: 0.537, lr: 0.05000\nLoss at epoch 20: training: 0.491, validation: 0.497, lr: 0.05000\nLoss at epoch 21: training: 0.589, validation: 0.444, lr: 0.05000\nLoss at epoch 22: training: 0.523, validation: 0.571, lr: 0.05000\nLoss at epoch 23: training: 0.508, validation: 0.593, lr: 0.05000\nLoss at epoch 24: training: 0.514, validation: 0.391, lr: 0.05000\nLoss at epoch 25: training: 0.505, validation: 0.596, lr: 0.05000\nLoss at epoch 26: training: 0.501, validation: 0.542, lr: 0.05000\nLoss at epoch 27: training: 0.532, validation: 0.542, lr: 0.05000\nLoss at epoch 28: training: 0.485, validation: 0.372, lr: 0.05000\nLoss at epoch 29: training: 0.468, validation: 0.544, lr: 0.05000\nLoss at epoch 30: training: 0.455, validation: 0.553, lr: 0.05000\nLoss at epoch 31: training: 0.453, validation: 0.414, lr: 0.05000\nLoss at epoch 32: training: 0.501, validation: 0.794, lr: 0.05000\nLoss at epoch 33: training: 0.488, validation: 0.386, lr: 0.05000\nLoss at epoch 34: training: 0.476, validation: 0.618, lr: 0.05000\nLoss at epoch 35: training: 0.570, validation: 0.888, lr: 0.05000\nLoss at epoch 36: training: 0.466, validation: 0.365, lr: 0.05000\nLoss at epoch 37: training: 0.522, validation: 0.466, lr: 0.05000\nLoss at epoch 38: training: 0.482, validation: 0.881, lr: 0.05000\nLoss at epoch 39: training: 0.534, validation: 0.386, lr: 0.05000\nLoss at epoch 40: training: 0.464, validation: 0.354, lr: 0.05000\n```\n:::\n\n```{.r .cell-code}\n# Predictions:\n\npredictions = predict(model, newdata = data_new)\n\nwrite.csv(data.frame(y = predictions[,1]), file = \"Max_titanic_dnn.csv\")\n```\n:::\n\n\n**Hints**\n\ncito has a feature to automatically tune hyperparameters under Cross Validation!\n\n- if you pass the function `tune(...)` to a hyperparameter, this hyperparameter will be automatically tuned\n- in the `tuning = config_tuning(...)` argument, you can specify the cross-validation strategy and the number of hyperparameters that shoudl be tested\n- after the tuning, cito will fit automatically a model with the best hyperparameters on the full data and will return this model\n\nMinimal example with the iris dataset:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf = iris\ndf[,1:4] = scale(df[,1:4])\n\nmodel_tuned = dnn(Species~., \n                  loss = \"softmax\",\n                  data = iris,\n                  lambda = tune(lower = 0.0, upper = 0.2), # you can pass the \"tune\" function to a hyerparameter\n                  tuning = config_tuning(CV = 3, steps = 20L)\n                  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarting hyperparameter tuning...\nFitting final model...\n```\n:::\n\n```{.r .cell-code}\n# tuning results\nmodel_tuned$tuning\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 5\n   steps  test train models lambda\n   <int> <dbl> <dbl> <lgl>   <dbl>\n 1     1  71.5     0 NA     0.0669\n 2     2  65.2     0 NA     0.0658\n 3     3  72.2     0 NA     0.0650\n 4     4  24.4     0 NA     0.0179\n 5     5 Inf       0 NA     0.199 \n 6     6  76.9     0 NA     0.0909\n 7     7  75.8     0 NA     0.0821\n 8     8  74.2     0 NA     0.0743\n 9     9  85.9     0 NA     0.107 \n10    10  81.7     0 NA     0.113 \n11    11 Inf       0 NA     0.157 \n12    12 Inf       0 NA     0.158 \n13    13  29.1     0 NA     0.0204\n14    14  87.4     0 NA     0.113 \n15    15 Inf       0 NA     0.162 \n16    16 Inf       0 NA     0.170 \n17    17 Inf       0 NA     0.141 \n18    18  80.0     0 NA     0.0984\n19    19 Inf       0 NA     0.173 \n20    20  81.2     0 NA     0.107 \n```\n:::\n\n```{.r .cell-code}\n# model_tuned is now already the best model!\nmodel_tuned\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(function (formula = NULL, data = NULL, hidden = c(50L, 50L), \n    activation = \"selu\", bias = TRUE, dropout = 0, loss = c(\"mse\", \n        \"mae\", \"softmax\", \"cross-entropy\", \"gaussian\", \"binomial\", \n        \"poisson\", \"mvp\", \"nbinom\", \"multinomial\", \"clogit\"), \n    validation = 0, lambda = 0, alpha = 0.5, optimizer = c(\"sgd\", \n        \"adam\", \"adadelta\", \"adagrad\", \"rmsprop\", \"rprop\"), lr = 0.01, \n    batchsize = NULL, burnin = 30, baseloss = NULL, shuffle = TRUE, \n    epochs = 100, bootstrap = NULL, bootstrap_parallel = FALSE, \n    plot = TRUE, verbose = TRUE, lr_scheduler = NULL, custom_parameters = NULL, \n    device = c(\"cpu\", \"cuda\", \"mps\"), early_stopping = FALSE, \n    tuning = config_tuning(), X = NULL, Y = NULL) \n{\n    out <- list()\n    class(out) <- \"citodnn\"\n    tuner = check_hyperparameters(hidden = hidden, bias = bias, \n        activation = activation, lambda = lambda, alpha = alpha, \n        dropout = dropout, batchsize = batchsize, epochs = epochs, \n        lr = lr)\n    device <- match.arg(device)\n    if (!is.function(loss) & !inherits(loss, \"family\")) {\n        loss <- match.arg(loss)\n        if ((device == \"mps\") & (loss %in% c(\"poisson\", \"nbinom\", \n            \"multinomial\"))) {\n            message(\"`poisson`, `nbinom`, and `multinomial` are not yet supported for `device=mps`, switching to `device=cpu`\")\n            device = \"cpu\"\n        }\n    }\n    if (inherits(loss, \"family\")) {\n        if ((device == \"mps\") & (loss$family %in% c(\"poisson\", \n            \"nbinom\"))) {\n            message(\"`poisson` or `nbinom` are not yet supported for `device=mps`, switching to `device=cpu`\")\n            device = \"cpu\"\n        }\n    }\n    device_old = device\n    device = check_device(device)\n    tmp_data = get_X_Y(formula, X, Y, data)\n    old_formula = tmp_data$old_formula\n    out$old_formula = old_formula\n    X = tmp_data$X\n    Y = tmp_data$Y\n    Z = tmp_data$Z\n    formula = tmp_data$formula\n    Z_formula = tmp_data$Z_terms\n    data = tmp_data$data\n    if (!is.null(Z)) {\n        Z_args = list()\n        for (i in 1:length(tmp_data$Z_args)) {\n            Z_args = append(Z_args, eval(tmp_data$Z_args[[i]]))\n        }\n        embeddings = list(inputs = ncol(Z), dims = apply(Z, 2, \n            function(z) length(levels(as.factor(z)))), args = Z_args)\n    }\n    else {\n        embeddings = NULL\n    }\n    if (is.null(batchsize)) \n        batchsize = round(0.1 * nrow(X))\n    if (is.null(Y)) {\n        net <- build_dnn(input = ncol(X), output = NULL, hidden = hidden, \n            activation = activation, bias = bias, dropout = dropout, \n            embeddings = embeddings)\n        model_properties <- list(input = ncol(X), output = NULL, \n            hidden = hidden, activation = activation, bias = bias, \n            dropout = dropout, embeddings = embeddings)\n        out$net <- net\n        out$call <- match.call()\n        out$call$formula <- stats::terms.formula(formula, data = data)\n        out$Z_formula = Z_formula\n        out$data <- list(X = X, Y = NULL, data = data, Z = Z)\n        out$data$xlvls <- lapply(data[, sapply(data, is.factor), \n            drop = F], function(j) levels(j))\n        out$model_properties <- model_properties\n        return(out)\n    }\n    loss_obj <- get_loss(loss, device = device, X = X, Y = Y)\n    if (!is.null(loss_obj$parameter)) \n        loss_obj$parameter <- list(parameter = loss_obj$parameter)\n    if (!is.null(custom_parameters)) {\n        if (!inherits(custom_parameters, \"list\")) {\n            warning(\"custom_parameters has to be list\")\n        }\n        else {\n            custom_parameters <- lapply(custom_parameters, function(x) torch::torch_tensor(x, \n                requires_grad = TRUE, device = device))\n            loss_obj$parameter <- append(loss_obj$parameter, \n                unlist(custom_parameters))\n        }\n    }\n    loss.fkt <- loss_obj$loss\n    if (!is.null(loss_obj$parameter)) \n        list2env(loss_obj$parameter, envir = environment(fun = loss.fkt))\n    response_column <- NULL\n    if (inherits(loss_obj$call, \"character\") && loss_obj$call == \n        \"softmax\") \n        response_column = as.character(LHSForm(formula))\n    targets <- format_targets(Y, loss_obj)\n    Y_torch <- targets$Y\n    Y_transformed = as.matrix(Y_torch)\n    Y_base <- targets$Y_base\n    y_dim <- targets$y_dim\n    ylvls <- targets$ylvls\n    responses <- targets$responses\n    X_torch <- torch::torch_tensor(X)\n    if (!is.null(embeddings)) {\n        Z_torch = torch::torch_tensor(Z, dtype = torch::torch_long())\n    }\n    else {\n        Z_torch = NULL\n    }\n    if (length(tuner) != 0) {\n        parameters = as.list(match.call())\n        parameters[!nzchar(names(parameters))] = NULL\n        model = tuning_function(tuner, parameters, loss.fkt, \n            loss_obj, X, Y, Z, data, old_formula, tuning, Y_torch, \n            loss, device_old)\n        return(model)\n    }\n    if (is.null(bootstrap) || !bootstrap) {\n        if (is.null(baseloss)) {\n            baseloss = as.numeric(loss.fkt(torch::torch_tensor(loss_obj$link(Y_base$cpu()), \n                dtype = Y_base$dtype)$to(device = device), Y_torch$to(device = device))$mean()$cpu())\n        }\n        if (validation != 0) {\n            n_samples <- nrow(X)\n            valid <- sort(sample(c(1:n_samples), replace = FALSE, \n                size = round(validation * n_samples)))\n            train <- c(1:n_samples)[-valid]\n            if (is.null(Z_torch)) {\n                train_dl <- get_data_loader(X_torch[train, ], \n                  Y_torch[train, ], batch_size = batchsize, shuffle = shuffle)\n                valid_dl <- get_data_loader(X_torch[valid, ], \n                  Y_torch[valid, ], batch_size = batchsize, shuffle = shuffle)\n            }\n            else {\n                train_dl <- get_data_loader(X_torch[train, ], \n                  Y_torch[train, ], Z_torch[train, ], batch_size = batchsize, \n                  shuffle = shuffle)\n                valid_dl <- get_data_loader(X_torch[valid, ], \n                  Y_torch[valid, ], Z_torch[valid, ], batch_size = batchsize, \n                  shuffle = shuffle)\n            }\n        }\n        else {\n            if (is.null(Z_torch)) {\n                train_dl <- get_data_loader(X_torch, Y_torch, \n                  batch_size = batchsize, shuffle = shuffle)\n            }\n            else {\n                train_dl <- get_data_loader(X_torch, Y_torch, \n                  Z_torch, batch_size = batchsize, shuffle = shuffle)\n            }\n            valid_dl <- NULL\n        }\n        net <- build_dnn(input = ncol(X), output = y_dim, hidden = hidden, \n            activation = activation, bias = bias, dropout = dropout, \n            embeddings = embeddings)\n        model_properties <- list(input = ncol(X), output = y_dim, \n            hidden = hidden, activation = activation, bias = bias, \n            dropout = dropout, embeddings = embeddings)\n        training_properties <- list(lr = lr, lr_scheduler = lr_scheduler, \n            optimizer = optimizer, epochs = epochs, early_stopping = early_stopping, \n            plot = plot, validation = validation, lambda = lambda, \n            alpha = alpha, batchsize = batchsize, shuffle = shuffle, \n            formula = formula, embeddings = embeddings)\n        out <- list()\n        class(out) <- \"citodnn\"\n        out$net <- net\n        out$call <- match.call()\n        out$call$formula <- stats::terms.formula(formula, data = data)\n        out$Z_formula = Z_formula\n        out$old_formula = old_formula\n        out$loss <- loss_obj\n        out$data <- list(X = X, Y = as.matrix(Y_torch), data = data, \n            Z = Z)\n        data_tmp = data[, labels(stats::terms(formula, data = data)), \n            drop = FALSE]\n        out$data$xlvls <- lapply(data_tmp[, sapply(data_tmp, \n            is.factor), drop = F], function(j) levels(j))\n        out$base_loss = baseloss\n        if (!is.null(ylvls)) {\n            out$data$ylvls <- ylvls\n            out$data$xlvls <- out$data$xlvls[-which(names(out$data$xlvls) %in% \n                as.character(formula[[2]]))]\n        }\n        if (validation != 0) \n            out$data <- append(out$data, list(validation = valid))\n        out$weights <- list()\n        out$use_model_epoch <- 1\n        out$loaded_model_epoch <- 0\n        out$model_properties <- model_properties\n        out$training_properties <- training_properties\n        out$device = device_old\n        out$responses = responses\n        out$burnin = burnin\n        out <- train_model(model = out, epochs = epochs, device = device, \n            train_dl = train_dl, valid_dl = valid_dl, verbose = verbose)\n    }\n    else {\n        out <- list()\n        class(out) <- \"citodnnBootstrap\"\n        if (bootstrap_parallel == FALSE) {\n            pb = progress::progress_bar$new(total = bootstrap, \n                format = \"[:bar] :percent :eta\", width = round(getOption(\"width\")/2))\n            models = list()\n            for (b in 1:bootstrap) {\n                indices <- sample(nrow(data), replace = TRUE)\n                m = do.call(dnn, args = list(formula = old_formula, \n                  data = data[indices, ], loss = loss, hidden = hidden, \n                  activation = activation, bias = bias, validation = validation, \n                  lambda = lambda, alpha = alpha, lr = lr, dropout = dropout, \n                  optimizer = optimizer, batchsize = batchsize, \n                  shuffle = shuffle, epochs = epochs, plot = FALSE, \n                  verbose = FALSE, bootstrap = NULL, device = device_old, \n                  custom_parameters = custom_parameters, lr_scheduler = lr_scheduler, \n                  early_stopping = early_stopping, bootstrap_parallel = FALSE))\n                m$data$indices = indices\n                m$data$original = list(data = data, X = X, Y = Y_transformed, \n                  Z = Z)\n                pb$tick()\n                models[[b]] = m\n            }\n        }\n        else {\n            if (is.logical(bootstrap_parallel)) {\n                bootstrap_parallel = parallel::detectCores() - \n                  1\n            }\n            if (is.numeric(bootstrap_parallel)) {\n                backend = parabar::start_backend(bootstrap_parallel)\n                parabar::export(backend, ls(environment()), environment())\n            }\n            parabar::configure_bar(type = \"modern\", format = \"[:bar] :percent :eta\", \n                width = round(getOption(\"width\")/2))\n            models <- parabar::par_lapply(backend, 1:bootstrap, \n                function(i) {\n                  indices <- sample(nrow(data), replace = TRUE)\n                  m = do.call(dnn, args = list(formula = old_formula, \n                    data = data[indices, ], loss = loss, hidden = hidden, \n                    activation = activation, bias = bias, validation = validation, \n                    lambda = lambda, alpha = alpha, lr = lr, \n                    dropout = dropout, optimizer = optimizer, \n                    batchsize = batchsize, shuffle = shuffle, \n                    epochs = epochs, plot = FALSE, verbose = FALSE, \n                    bootstrap = NULL, device = device_old, custom_parameters = custom_parameters, \n                    lr_scheduler = lr_scheduler, early_stopping = early_stopping, \n                    bootstrap_parallel = FALSE))\n                  m$data$indices = indices\n                  m$data$original = list(data = data, X = X, \n                    Y = Y_transformed, Z = Z)\n                  m\n                })\n            if (!is.null(backend)) \n                parabar::stop_backend(backend)\n        }\n        out$models <- models\n        out$data <- list(X = X, Y = as.matrix(Y_torch), data = data, \n            Z = Z)\n        out$device = device_old\n        out$responses = responses\n        out$loss = loss_obj$call\n        out$response_column = response_column\n        out$old_formula = old_formula\n        out$successfull = any(!sapply(models, function(m) m$successfull) == \n            0)\n    }\n    return(out)\n})(formula = Species ~ Sepal.Length + Sepal.Width + Petal.Length + \n    Petal.Width - 1, data = list(Sepal.Length = c(5.1, 4.9, 4.7, \n4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 5.8, 5.7, \n5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 5.2, 5.2, \n4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 5, 4.5, \n4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 6.5, 5.7, \n6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 5.8, 6.2, \n5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 5.5, 5.5, \n5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, 5, 5.6, 5.7, \n5.7, 6.2, 5.1, 5.7, 6.3, 5.8, 7.1, 6.3, 6.5, 7.6, 4.9, 7.3, 6.7, \n7.2, 6.5, 6.4, 6.8, 5.7, 5.8, 6.4, 6.5, 7.7, 7.7, 6, 6.9, 5.6, \n7.7, 6.3, 6.7, 7.2, 6.2, 6.1, 6.4, 7.2, 7.4, 7.9, 6.4, 6.3, 6.1, \n7.7, 6.3, 6.4, 6, 6.9, 6.7, 6.9, 5.8, 6.8, 6.7, 6.7, 6.3, 6.5, \n6.2, 5.9), Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, \n2.9, 3.1, 3.7, 3.4, 3, 3, 4, 4.4, 3.9, 3.5, 3.8, 3.8, 3.4, 3.7, \n3.6, 3.3, 3.4, 3, 3.4, 3.5, 3.4, 3.2, 3.1, 3.4, 4.1, 4.2, 3.1, \n3.2, 3.5, 3.6, 3, 3.4, 3.5, 2.3, 3.2, 3.5, 3.8, 3, 3.8, 3.2, \n3.7, 3.3, 3.2, 3.2, 3.1, 2.3, 2.8, 2.8, 3.3, 2.4, 2.9, 2.7, 2, \n3, 2.2, 2.9, 2.9, 3.1, 3, 2.7, 2.2, 2.5, 3.2, 2.8, 2.5, 2.8, \n2.9, 3, 2.8, 3, 2.9, 2.6, 2.4, 2.4, 2.7, 2.7, 3, 3.4, 3.1, 2.3, \n3, 2.5, 2.6, 3, 2.6, 2.3, 2.7, 3, 2.9, 2.9, 2.5, 2.8, 3.3, 2.7, \n3, 2.9, 3, 3, 2.5, 2.9, 2.5, 3.6, 3.2, 2.7, 3, 2.5, 2.8, 3.2, \n3, 3.8, 2.6, 2.2, 3.2, 2.8, 2.8, 2.7, 3.3, 3.2, 2.8, 3, 2.8, \n3, 2.8, 3.8, 2.8, 2.8, 2.6, 3, 3.4, 3.1, 3, 3.1, 3.1, 3.1, 2.7, \n3.2, 3.3, 3, 2.5, 3, 3.4, 3), Petal.Length = c(1.4, 1.4, 1.3, \n1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.6, 1.4, 1.1, 1.2, 1.5, \n1.3, 1.4, 1.7, 1.5, 1.7, 1.5, 1, 1.7, 1.9, 1.6, 1.6, 1.5, 1.4, \n1.6, 1.6, 1.5, 1.5, 1.4, 1.5, 1.2, 1.3, 1.4, 1.3, 1.5, 1.3, 1.3, \n1.3, 1.6, 1.9, 1.4, 1.6, 1.4, 1.5, 1.4, 4.7, 4.5, 4.9, 4, 4.6, \n4.5, 4.7, 3.3, 4.6, 3.9, 3.5, 4.2, 4, 4.7, 3.6, 4.4, 4.5, 4.1, \n4.5, 3.9, 4.8, 4, 4.9, 4.7, 4.3, 4.4, 4.8, 5, 4.5, 3.5, 3.8, \n3.7, 3.9, 5.1, 4.5, 4.5, 4.7, 4.4, 4.1, 4, 4.4, 4.6, 4, 3.3, \n4.2, 4.2, 4.2, 4.3, 3, 4.1, 6, 5.1, 5.9, 5.6, 5.8, 6.6, 4.5, \n6.3, 5.8, 6.1, 5.1, 5.3, 5.5, 5, 5.1, 5.3, 5.5, 6.7, 6.9, 5, \n5.7, 4.9, 6.7, 4.9, 5.7, 6, 4.8, 4.9, 5.6, 5.8, 6.1, 6.4, 5.6, \n5.1, 5.6, 6.1, 5.6, 5.5, 4.8, 5.4, 5.6, 5.1, 5.1, 5.9, 5.7, 5.2, \n5, 5.2, 5.4, 5.1), Petal.Width = c(0.2, 0.2, 0.2, 0.2, 0.2, 0.4, \n0.3, 0.2, 0.2, 0.1, 0.2, 0.2, 0.1, 0.1, 0.2, 0.4, 0.4, 0.3, 0.3, \n0.3, 0.2, 0.4, 0.2, 0.5, 0.2, 0.2, 0.4, 0.2, 0.2, 0.2, 0.2, 0.4, \n0.1, 0.2, 0.2, 0.2, 0.2, 0.1, 0.2, 0.2, 0.3, 0.3, 0.2, 0.6, 0.4, \n0.3, 0.2, 0.2, 0.2, 0.2, 1.4, 1.5, 1.5, 1.3, 1.5, 1.3, 1.6, 1, \n1.3, 1.4, 1, 1.5, 1, 1.4, 1.3, 1.4, 1.5, 1, 1.5, 1.1, 1.8, 1.3, \n1.5, 1.2, 1.3, 1.4, 1.4, 1.7, 1.5, 1, 1.1, 1, 1.2, 1.6, 1.5, \n1.6, 1.5, 1.3, 1.3, 1.3, 1.2, 1.4, 1.2, 1, 1.3, 1.2, 1.3, 1.3, \n1.1, 1.3, 2.5, 1.9, 2.1, 1.8, 2.2, 2.1, 1.7, 1.8, 1.8, 2.5, 2, \n1.9, 2.1, 2, 2.4, 2.3, 1.8, 2.2, 2.3, 1.5, 2.3, 2, 2, 1.8, 2.1, \n1.8, 1.8, 1.8, 2.1, 1.6, 1.9, 2, 2.2, 1.5, 1.4, 2.3, 2.4, 1.8, \n1.8, 2.1, 2.4, 2.3, 1.9, 2.3, 2.5, 2.3, 1.9, 2, 2.3, 1.8), Species = c(1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, \n2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, \n2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, \n2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, \n3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, \n3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, 3L, \n3L, 3L, 3L, 3L, 3L)), loss = \"softmax\", lambda = c(lambda = 0.0179034829605371), \n    bootstrap = FALSE, bootstrap_parallel = FALSE, plot = FALSE, \n    verbose = FALSE, tuning = config_tuning(CV = 3, steps = 20L))\nAn `nn_module` containing 2,953 parameters.\n\n── Modules ─────────────────────────────────────────────────────────────────────\n• 0: <nn_linear> #250 parameters\n• 1: <nn_selu> #0 parameters\n• 2: <nn_linear> #2,550 parameters\n• 3: <nn_selu> #0 parameters\n• 4: <nn_linear> #153 parameters\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-warning}\n#### Question: Hyperparameter tuning - Plant-pollinator dataset\n\nsee @sec-plantpoll for more information about the dataset.\n\nPrepare the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\nlibrary(missRanger)\nlibrary(dplyr)\ndata(plantPollinator_df)\nplant_poll = plantPollinator_df\n\nplant_poll_imputed = plant_poll %>% select(diameter,\n                                           corolla,\n                                           tongue,\n                                           body,\n                                           interaction,\n                                           colour, \n                                           nectar,\n                                           feeding,\n                                           season)\n# Remove response variable interaction\nplant_poll_imputed = missRanger::missRanger(data = plant_poll_imputed %>%\n                                              select(-interaction), verbose = 0)\n\n# scale numeric variables\nplant_poll_imputed[,sapply(plant_poll_imputed, is.numeric)] = scale(plant_poll_imputed[,sapply(plant_poll_imputed, is.numeric)])\n\n# Add response back to the dataset after the imputatiob\nplant_poll_imputed$interaction = plant_poll$interaction\nplant_poll_imputed$colour = as.factor(plant_poll_imputed$colour)\nplant_poll_imputed$nectar = as.factor(plant_poll_imputed$nectar)\nplant_poll_imputed$feeding = as.factor(plant_poll_imputed$feeding)\nplant_poll_imputed$season = as.factor(plant_poll_imputed$season)\n\n\ndata_new = plant_poll_imputed[is.na(plant_poll_imputed$interaction), ] # for which we want to make predictions at the end\ndata_obs = plant_poll_imputed[!is.na(plant_poll_imputed$interaction), ]# data with known response\ndim(data_obs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14690     9\n```\n:::\n:::\n\n\nThe dataset is large! More than 10,000 observations. For now, let's switch to a simple holdout strategy for validating our model (e.g. use 80% of the data to train the model and 20% of the data to validate your model.\n\nMoreover:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(data_obs$interaction)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    0     1 \n14095   595 \n```\n:::\n:::\n\n\nThe data is strongly imbalanced, i.e. many 0s but only a few 1. There are different strategies how to deal with that, for example oversampling the 1s or undersampling the 0s.\n\nUndersampling the 0s:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_obs = data_obs[c(sample(which(data_obs$interaction == 0), 2000), which(data_obs$interaction == 1)),]\ntable(data_obs$interaction)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n   0    1 \n2000  595 \n```\n:::\n\n```{.r .cell-code}\ndata_obs$interaction = as.integer(data_obs$interaction)\n```\n:::\n\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\nMinimal example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cito)\nset.seed(42)\ntuning_steps = 2\nhyper_lambda = runif(tuning_steps,0.0001, 0.02)\nhyper_alpha = runif(tuning_steps,0, 1.0)\nhyper_hidden = sample.int(10, tuning_steps)\nhyper_nodes = sample(seq(5, 100), size = tuning_steps)\n\nouter_split = sample(nrow(data_obs), 0.2*nrow(data_obs))\n\nresults = data.frame(\n  set = 1,\n  lambda = rep(NA, 1),\n  alpha = rep(NA, 1),\n  hidden = rep(NA, 1),\n  nodes = rep(NA, 1),\n  AUC = rep(NA, 1)\n)\n\ntrain_outer = data_obs[-outer_split, ]\ntest_outer = data_obs[outer_split, ]\n\ntuning_results = \n    sapply(1:length(hyper_lambda), function(k) {\n      model = dnn(interaction~., \n          hidden = rep(hyper_nodes[k], hyper_hidden[k]), \n          activation = rep(\"selu\", hyper_hidden[k]), \n          loss = \"binomial\", \n          lr = 0.05,\n          lambda = hyper_lambda[k],\n          alpha = hyper_alpha[k],\n          batchsize = 100L, # increasing the batch size will reduce the runtime\n          lr_scheduler = config_lr_scheduler(\"reduce_on_plateau\", patience = 10, factor = 0.9),\n          data = train_outer, epochs = 50L, verbose = FALSE, plot= FALSE)\n      return(Metrics::auc(test_outer$interaction, predict(model, test_outer )[,1]))\n    })\nresults[1, 1] = 1\nresults[1, 2] =  hyper_lambda[which.max(tuning_results)]\nresults[1, 3] =  hyper_alpha[which.max(tuning_results)]\nresults[1, 4] =  hyper_hidden[which.max(tuning_results)]\nresults[1, 5] =  hyper_nodes[which.max(tuning_results)]  \nresults[1, 6] = max(tuning_results)\n\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  set    lambda     alpha hidden nodes       AUC\n1   1 0.0187478 0.8304476      4    53 0.5359656\n```\n:::\n:::\n\n\nMake predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk = 1\nmodel = dnn(interaction~., \n    hidden = rep(results$nodes[k], results$hidden[k]), \n    activation = rep(\"selu\", hyper_hidden[k]), \n    loss = \"binomial\", \n    lr = 0.05,\n    lambda = results$lambda[k],\n    alpha = results$alpha[k],\n    batchsize = 100L, # increasing the batch size will reduce the runtime\n    lr_scheduler = config_lr_scheduler(\"reduce_on_plateau\", patience = 10, factor = 0.9),\n    data = train_outer, epochs = 50L, verbose = FALSE, plot= FALSE)\n\npredictions = predict(model, newdata = data_new)[,1]\n\nwrite.csv(data.frame(y = predictions), file = \"Max_plant_poll_ensemble.csv\")\n```\n:::\n\n\n\n</div>\n\n:::\n",
    "supporting": [
      "B3-NeuralNetworks_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}