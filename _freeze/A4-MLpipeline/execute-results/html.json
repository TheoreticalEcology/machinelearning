{
  "hash": "f0f894beeccb7aedab1e9eb608743efe",
  "result": {
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n# Machine learning pipeline {#workflow}\n\nThe Standard Machine Learning Pipeline using the Titanic Data set\n\nBefore we specialize on any tuning, it is important to understand that machine learning always consists of a pipeline of actions.\n\nThe typical machine learning workflow consist of:\n\n-   Data cleaning and exploration (EDA = explorative data analysis) for example with tidyverse.\n-   Preprocessing and feature selection.\n-   Splitting data set into training and test set for evaluation.\n-   Model fitting.\n-   Model evaluation.\n-   New predictions\n\n![Machine Learning pipeline](images/pipeline.png)\n\n<!-- Here is an (optional) video that explains the entire pipeline from a slightly different perspective: -->\n\n<!-- ```{r chunk_chapter4_39, eval=knitr::is_html_output(excludes = \"epub\"), results = 'asis', echo = F} -->\n\n<!-- cat( -->\n\n<!--   '<iframe width=\"560\" height=\"315\"  -->\n\n<!--   src=\"https://www.youtube.com/embed/nKW8Ndu7Mjw\" -->\n\n<!--   frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; -->\n\n<!--   gyroscope; picture-in-picture\" allowfullscreen> -->\n\n<!--   </iframe>' -->\n\n<!-- ) -->\n\n<!-- ``` -->\n\nIn the following example, we use tidyverse, a collection of R packages for data science / data manipulation mainly developed by Hadley Wickham.\n\n::: {.callout-note appearance=\"default\" collapse=\"true\"}\n## dplyr and tidyverse\n\nThe `dplyr` package is part of a framework called tidyverse. Unique features of the tidyverse are the pipe `%>%` operator and `tibble` objects.\n\n-   The `%>%` operator:\n\n    Applying several functions in sequence on an object often results in uncountable/confusing number of round brackets:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    library(tidyverse)\n    ```\n    \n    ::: {.cell-output .cell-output-stderr}\n    ```\n    ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n    ✔ dplyr     1.1.4     ✔ readr     2.1.5\n    ✔ forcats   1.0.0     ✔ stringr   1.5.1\n    ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n    ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n    ✔ purrr     1.0.2     \n    ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n    ✖ dplyr::filter() masks stats::filter()\n    ✖ dplyr::lag()    masks stats::lag()\n    ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    max(mean(range(c(5, 3, 2, 1))))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 3\n    ```\n    :::\n    :::\n\n\n    The pipe operator simplifies that by saying \"apply the next function on the result of the current function\":\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(5, 3, 2, 1) %>% range %>% mean %>% max\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 3\n    ```\n    :::\n    :::\n\n\n    Which is easier to write, read, and to understand!\n\n-   `tibble` objects are just an extension of data.frames. In the course we will use mostly data.frames, so it is better to transform the tibbles back to data.frames:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    air_grouped = airquality %>% group_by(Month)\n    \n    class(air_grouped)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"grouped_df\" \"tbl_df\"     \"tbl\"        \"data.frame\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    air_grouped = as.data.frame(air_grouped)\n    class(air_grouped)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"data.frame\"\n    ```\n    :::\n    :::\n\n:::\n\n<!-- ```{r chunk_chapter4_40, eval=knitr::is_html_output(excludes = \"epub\"), results = 'asis', echo = F} -->\n\n<!-- cat( -->\n\n<!--   '<iframe width=\"560\" height=\"315\"  -->\n\n<!--   src=\"https://www.youtube.com/embed/nRtp7wSEtJA\" -->\n\n<!--   frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; -->\n\n<!--   gyroscope; picture-in-picture\" allowfullscreen> -->\n\n<!--   </iframe>' -->\n\n<!-- ) -->\n\n<!-- ``` -->\n\n::: column-margin\nAnother good reference is \"**R for data science**\" by Hadley Wickham: <a href=\"https://r4ds.had.co.nz/\" target=\"_blank\" rel=\"noopener\"></a>.\n:::\n\nFor this lecture you need the Titanic data set provided by us (via the `EcoData` package).\n\n::: column-margin\nYou can find it in GRIPS (datasets.RData in the data set and submission section) or at <a href=\"http://rhsbio7.uni-regensburg.de:8500\" target=\"_blank\" rel=\"noopener\">http://rhsbio7.uni-regensburg.de:8500</a> (VPN for University of Regensburg is required!).\n:::\n\n::: callout-important\n### Motivation - We need a model that can predict the survival probability of new passengers.\n\nWe have split the data set into training and an outer test/prediction data sets (the test/prediction split has one column less than the train split, as the response for the test/outer split is unknown).\n\n**The goal is to build a predictive model that can accurately predict the chances of survival for Titanic passengers!**\n\nThe dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(EcoData)\ndata(titanic_ml)\ndata = titanic_ml\n```\n:::\n\n\nThe response variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(data$survived)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  0 NA\n```\n:::\n:::\n\n\n0 = passenger died\n\n1 = passenger survived\n\nNA = we don't have information about the passenger, at the end, we will make predictions for these passengers!\n\n**Important**: Preprocessing of the data must be done for the training and testing data together!!\n:::\n\n## Data preparation\n\nLoad necessary libraries:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nLoad data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\ndata(titanic_ml)\ndata = titanic_ml\n```\n:::\n\n\nStandard summaries:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t1309 obs. of  14 variables:\n $ pclass   : int  2 1 3 3 3 3 3 1 3 1 ...\n $ survived : int  1 1 0 0 0 0 0 1 0 1 ...\n $ name     : chr  \"Sinkkonen, Miss. Anna\" \"Woolner, Mr. Hugh\" \"Sage, Mr. Douglas Bullen\" \"Palsson, Master. Paul Folke\" ...\n $ sex      : Factor w/ 2 levels \"female\",\"male\": 1 2 2 2 2 2 2 1 1 1 ...\n $ age      : num  30 NA NA 6 30.5 38.5 20 53 NA 42 ...\n $ sibsp    : int  0 0 8 3 0 0 0 0 0 0 ...\n $ parch    : int  0 0 2 1 0 0 0 0 0 0 ...\n $ ticket   : Factor w/ 929 levels \"110152\",\"110413\",..: 221 123 779 542 589 873 472 823 588 834 ...\n $ fare     : num  13 35.5 69.55 21.07 8.05 ...\n $ cabin    : Factor w/ 187 levels \"\",\"A10\",\"A11\",..: 1 94 1 1 1 1 1 1 1 1 ...\n $ embarked : Factor w/ 4 levels \"\",\"C\",\"Q\",\"S\": 4 4 4 4 4 4 4 2 4 2 ...\n $ boat     : Factor w/ 28 levels \"\",\"1\",\"10\",\"11\",..: 3 28 1 1 1 1 1 19 1 15 ...\n $ body     : int  NA NA NA NA 50 32 NA NA NA NA ...\n $ home.dest: Factor w/ 370 levels \"\",\"?Havana, Cuba\",..: 121 213 1 1 1 1 322 350 1 1 ...\n```\n:::\n\n```{.r .cell-code}\nsummary(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     pclass         survived          name               sex     \n Min.   :1.000   Min.   :0.0000   Length:1309        female:466  \n 1st Qu.:2.000   1st Qu.:0.0000   Class :character   male  :843  \n Median :3.000   Median :0.0000   Mode  :character               \n Mean   :2.295   Mean   :0.3853                                  \n 3rd Qu.:3.000   3rd Qu.:1.0000                                  \n Max.   :3.000   Max.   :1.0000                                  \n                 NA's   :655                                     \n      age              sibsp            parch            ticket    \n Min.   : 0.1667   Min.   :0.0000   Min.   :0.000   CA. 2343:  11  \n 1st Qu.:21.0000   1st Qu.:0.0000   1st Qu.:0.000   1601    :   8  \n Median :28.0000   Median :0.0000   Median :0.000   CA 2144 :   8  \n Mean   :29.8811   Mean   :0.4989   Mean   :0.385   3101295 :   7  \n 3rd Qu.:39.0000   3rd Qu.:1.0000   3rd Qu.:0.000   347077  :   7  \n Max.   :80.0000   Max.   :8.0000   Max.   :9.000   347082  :   7  \n NA's   :263                                        (Other) :1261  \n      fare                     cabin      embarked      boat    \n Min.   :  0.000                  :1014    :  2           :823  \n 1st Qu.:  7.896   C23 C25 C27    :   6   C:270    13     : 39  \n Median : 14.454   B57 B59 B63 B66:   5   Q:123    C      : 38  \n Mean   : 33.295   G6             :   5   S:914    15     : 37  \n 3rd Qu.: 31.275   B96 B98        :   4            14     : 33  \n Max.   :512.329   C22 C26        :   4            4      : 31  \n NA's   :1         (Other)        : 271            (Other):308  \n      body                      home.dest  \n Min.   :  1.0                       :564  \n 1st Qu.: 72.0   New York, NY        : 64  \n Median :155.0   London              : 14  \n Mean   :160.8   Montreal, PQ        : 10  \n 3rd Qu.:256.0   Cornwall / Akron, OH:  9  \n Max.   :328.0   Paris, France       :  9  \n NA's   :1188    (Other)             :639  \n```\n:::\n:::\n\n\nThe name variable consists of 1309 unique factors (there are 1309 observations...) and could be now transformed. If you are interested in how to do that, take a look at the following box.\n\n::: {.callout-tip collapse=\"true\"}\n## Feature engineering of the name variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(unique(data$name))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1307\n```\n:::\n:::\n\n\nHowever, there is a title in each name. Let's extract the titles:\n\n1.  We will extract all names and split each name after each comma \",\".\n2.  We will split the second split of the name after a point \".\" and extract the titles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_split = sapply(data$name,\n                     function(x) stringr::str_split(x, pattern = \",\")[[1]][2])\ntitles = sapply(first_split,\n                function(x) strsplit(x, \".\",fixed = TRUE)[[1]][1])\n```\n:::\n\n\nWe get 18 unique titles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(titles)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntitles\n         Capt           Col           Don          Dona            Dr \n            1             4             1             1             8 \n     Jonkheer          Lady         Major        Master          Miss \n            1             1             2            61           260 \n         Mlle           Mme            Mr           Mrs            Ms \n            2             1           757           197             2 \n          Rev           Sir  the Countess \n            8             1             1 \n```\n:::\n:::\n\n\nA few titles have a very low occurrence rate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitles = stringr::str_trim((titles))\ntitles %>%\n fct_count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 18 × 2\n   f                n\n   <fct>        <int>\n 1 Capt             1\n 2 Col              4\n 3 Don              1\n 4 Dona             1\n 5 Dr               8\n 6 Jonkheer         1\n 7 Lady             1\n 8 Major            2\n 9 Master          61\n10 Miss           260\n11 Mlle             2\n12 Mme              1\n13 Mr             757\n14 Mrs            197\n15 Ms               2\n16 Rev              8\n17 Sir              1\n18 the Countess     1\n```\n:::\n:::\n\n\nWe will combine titles with low occurrences into one title, which we can easily do with the `forcats` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitles2 =\n  forcats::fct_collapse(titles,\n                        officer = c(\"Capt\", \"Col\", \"Major\", \"Dr\", \"Rev\"),\n                        royal = c(\"Jonkheer\", \"Don\", \"Sir\",\n                                  \"the Countess\", \"Dona\", \"Lady\"),\n                        miss = c(\"Miss\", \"Mlle\"),\n                        mrs = c(\"Mrs\", \"Mme\", \"Ms\")\n                        )\n```\n:::\n\n\nWe can count titles again to see the new number of titles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitles2 %>%  \n   fct_count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  f           n\n  <fct>   <int>\n1 officer    23\n2 royal       6\n3 Master     61\n4 miss      262\n5 mrs       200\n6 Mr        757\n```\n:::\n:::\n\n\nAdd new title variable to data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata =\n  data %>%\n    mutate(title = titles2)\n```\n:::\n\n:::\n\n### Imputation\n\nNAs are a common problem in ML and most ML algorithms cannot handle NAs. For example, the age variable has 20% NAs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(data$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.1667 21.0000 28.0000 29.8811 39.0000 80.0000     263 \n```\n:::\n\n```{.r .cell-code}\nsum(is.na(data$age)) / nrow(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2009167\n```\n:::\n:::\n\n\nThere are few options how to handle NAs:\n\n-   Drop observations with NAs, however, we may lose many observations (not what we want!)\n\n-   Imputation, fill the missing values\n\nWe impute (fill) the missing values, for example with the median age. However, age itself might depend on other variables such as sex, class and title. Thus, instead of filling the NAs with the overall median of the passengers, we want to fill the NAs with the median age of these groups so that the associations with the other groups are preserved (or in other words, that the new values are hopefully closer to the unknown true values).\n\nIn `tidyverse` we can \"group\" the data, i.e. we will nest the observations within categorical variables for which we assume that there may be an association with age (here: `group_by` after sex, pclass and title). After grouping, all operations (such as our `median(age....)`) will be done within the specified groups (to get better estimates of these missing NAs).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata =\n  data %>%\n    select(survived, sex, age, fare, pclass) %>% \n    group_by(sex, pclass) %>%\n    mutate(age2 = ifelse(is.na(age), median(age, na.rm = TRUE), age)) %>%\n    mutate(fare2 = ifelse(is.na(fare), median(fare, na.rm = TRUE), fare)) %>%\n    ungroup()\n```\n:::\n\n\n### Preprocessing and Feature Selection\n\nLater (tomorrow), we want to use Keras in our example, but it cannot handle factors and requires the data to be scaled.\n\nNormally, one would do this for all predictors, but as we only show the pipeline here, we have sub-selected a bunch of predictors and do this only for them. We first scale the numeric predictors and change the factors with only two groups/levels into integers (this can be handled by Keras).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_sub =\n  data %>%\n    select(survived, sex, age2, fare2, pclass) %>%\n    mutate(age2 = scales::rescale(age2, c(0, 1)),\n           fare2 = scales::rescale(fare2, c(0, 1))) %>%\n    mutate(sex = as.integer(sex) - 1L,\n           pclass = as.integer(pclass - 1L))\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Transforming factors with more than two levels\n\nFactors with more than two levels should be **one hot encoded** (Make columns for every different factor level and write 1 in the respective column for every taken feature value and 0 else. For example: $\\{red, green, green, blue, red\\} \\rightarrow \\{(0,0,1), (0,1,0), (0,1,0), (1,0,0), (0,0,1)\\}$):\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_title = model.matrix(~0+as.factor(title), data = data)\ncolnames(one_title) = levels(data$title)\n\none_sex = model.matrix(~0+as.factor(sex), data = data)\ncolnames(one_sex) = levels(data$sex)\n\none_pclass = model.matrix(~0+as.factor(pclass), data = data)\ncolnames(one_pclass) = paste0(\"pclass\", 1:length(unique(data$pclass)))\n```\n:::\n\n\nAnd we have to add the dummy encoded variables to the data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = cbind(data.frame(survived= data$survived),\n                 one_title, one_sex, age = data$age2,\n                 fare = data$fare2, one_pclass)\nhead(data)\n```\n:::\n\n:::\n\n## Modelling\n\n### Split data for final predictions\n\nTo tune our hyperparameters and evaluate our models, we split the data into the training and testing data. The testing data are the observations where the response is NA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(data_sub$survived)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.0000  0.0000  0.3853  1.0000  1.0000     655 \n```\n:::\n:::\n\n\n655 observations have NAs in our response variable, these are the observations for which we want to make predictions at the end of our pipeline.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_new = data_sub[is.na(data_sub$survived),]\ndata_obs = data_sub[!is.na(data_sub$survived),]\n```\n:::\n\n\n### Hyperparameter optimization\n\nWe want to tune our hyperparameters ($\\lambda$ and $\\alpha$). Normally, we should do a nested CV on our training data (data_obs), however, we assume that the test data on the submission server is our outer split, so we can tune our hyperparameters using a n-fold Cross-Validation which serves as our inner CV.\n\n::: column-margin\nAgain, why is it important to tune hyperparameters? Hyperparameters (configuration parameters of our ML algorithms that (mostly) control their complexity) are usually tuned (optimized) in an automatic / systematic way. A common procedure, called random search, is to sample random configuration combinations from the set of hyperparameters and test for each combination the prediction error.\n:::\n\nWe implement manually a CV to tune the learning rate. We start with a 3xCV and 10x different learning rates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cito)\nset.seed(42)\nmodel = dnn(survived~.,\n            data = data_obs, \n            loss = \"binomial\",\n            lr = tune(0.001, 0.1),\n            tuning = config_tuning(CV = 3, steps = 10)\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarting hyperparameter tuning...\nFitting final model...\n```\n:::\n\n```{.r .cell-code}\nmodel$tuning\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 5\n   steps  test train models      lr\n   <int> <dbl> <dbl> <lgl>    <dbl>\n 1     1  323.     0 NA     0.0394 \n 2     2  332.     0 NA     0.0623 \n 3     3  317.     0 NA     0.0627 \n 4     4  322.     0 NA     0.0804 \n 5     5  322.     0 NA     0.0658 \n 6     6  322.     0 NA     0.0683 \n 7     7  321.     0 NA     0.0417 \n 8     8  325.     0 NA     0.0667 \n 9     9  347.     0 NA     0.00368\n10    10  315.     0 NA     0.0818 \n```\n:::\n:::\n\n\n<!-- ```{r} -->\n\n<!-- library(glmnet) -->\n\n<!-- library(glmnetUtils) -->\n\n<!-- set.seed(42) -->\n\n<!-- cv = 5 -->\n\n<!-- hyper_lambda = runif(20,0, 0.2) -->\n\n<!-- tuning_results =  -->\n\n<!--     sapply(1:length(hyper_lambda), function(k) { -->\n\n<!--         auc_inner = NULL # save results from CV -->\n\n<!--         for(j in 1:cv) { -->\n\n<!--           inner_split = as.integer(cut(1:nrow(data_obs), breaks = cv)) -->\n\n<!--           train_inner = data_obs[inner_split != j, ] -->\n\n<!--           test_inner = data_obs[inner_split == j, ] -->\n\n<!--           model = glmnet(survived~.,data = train_inner, family = \"binomial\", lambda = hyper_lambda[k]) -->\n\n<!--           auc_inner[j]= Metrics::auc(test_inner$survived, predict(model, test_inner, type = \"response\")) -->\n\n<!--         } -->\n\n<!--       return(mean(auc_inner)) -->\n\n<!--     }) -->\n\n<!-- results = data.frame(lambda = hyper_lambda, AUC = tuning_results) -->\n\n<!-- print(results) -->\n\n<!-- ``` -->\n\n<!-- The best (highest AUC) $\\lambda$ is then: -->\n\n<!-- ```{r} -->\n\n<!-- results[which.max(results$AUC),] -->\n\n<!-- ``` -->\n\n## Predictions and Submission\n\nWhen we are satisfied with the performance of our model, we will create predictions for the new observations on the submission server. cito directly returns the best model so we do not have to fit the final model.\n\nWe submit our predictions to the submission server at <a href=\"http://rhsbio7.uni-regensburg.de:8500\" target=\"_blank\" rel=\"noopener\">http://rhsbio7.uni-regensburg.de:8500</a>.\n\nFor the submission it is critical to change the predictions into a data.frame, select the second column (the probability to survive), and save it with the write.csv function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_new = data_sub[is.na(data_sub$survived),]\npredictions = predict(model, data_new, type = \"response\")[,1] \nwrite.csv(data.frame(y = predictions), file = \"Max_1.csv\")\n```\n:::\n\n\n## Machine learning frameworks - Bonus\n\nAs we have seen today, many of the machine learning algorithms are distributed over several packages but the general machine learning pipeline is very similar for all models: feature engineering, feature selection, hyperparameter tuning and cross-validation.\n\nMachine learning frameworks such as `mlr3` or `tidymodels` provide a general interface for the ML pipeline, in particular the training and the hyperparameter tuning with nested CV. They support most ML packages/algorithms.\n\n### mlr3 {#sec-mlr}\n\nThe key features of mlr3 are:\n\n-   All common machine learning packages are integrated into mlr3, you can easily switch between different machine learning algorithms.\n-   A common 'language'/workflow to specify machine learning pipelines.\n-   Support for different cross-validation strategies.\n-   Hyperparameter tuning for all supported machine learning algorithms.\n-   Ensemble models.\n\nUseful links:\n\n-   <a href=\"https://mlr3book.mlr-org.com/\" target=\"_blank\" rel=\"noopener\">mlr3-book</a> (still in work)\n-   <a href=\"https://mlr3.mlr-org.com/\" target=\"_blank\" rel=\"noopener\">mlr3 website</a>\n-   <a href=\"https://cheatsheets.mlr-org.com/mlr3.pdf\" target=\"_blank\" rel=\"noopener\">mlr3 cheatsheet</a>\n\n#### mlr3 - The Basic Workflow\n\nThe mlr3 package actually consists of several packages for different tasks (e.g. mlr3tuning for hyperparameter tuning, mlr3pipelines for data preparation pipes). But let's start with the basic workflow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\nlibrary(tidyverse)\nlibrary(mlr3)\nlibrary(mlr3learners)\nlibrary(mlr3pipelines)\nlibrary(mlr3tuning)\nlibrary(mlr3measures)\ndata(nasa)\nstr(nasa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t4687 obs. of  40 variables:\n $ Neo.Reference.ID            : int  3449084 3702322 3406893 NA 2363305 3017307 2438430 3653917 3519490 2066391 ...\n $ Name                        : int  NA 3702322 3406893 3082923 2363305 3017307 2438430 3653917 3519490 NA ...\n $ Absolute.Magnitude          : num  18.7 22.1 24.8 21.6 21.4 18.2 20 21 20.9 16.5 ...\n $ Est.Dia.in.KM.min.          : num  0.4837 0.1011 0.0291 0.1272 0.1395 ...\n $ Est.Dia.in.KM.max.          : num  1.0815 0.226 0.0652 0.2845 0.3119 ...\n $ Est.Dia.in.M.min.           : num  483.7 NA 29.1 127.2 139.5 ...\n $ Est.Dia.in.M.max.           : num  1081.5 226 65.2 284.5 311.9 ...\n $ Est.Dia.in.Miles.min.       : num  0.3005 0.0628 NA 0.0791 0.0867 ...\n $ Est.Dia.in.Miles.max.       : num  0.672 0.1404 0.0405 0.1768 0.1938 ...\n $ Est.Dia.in.Feet.min.        : num  1586.9 331.5 95.6 417.4 457.7 ...\n $ Est.Dia.in.Feet.max.        : num  3548 741 214 933 1023 ...\n $ Close.Approach.Date         : Factor w/ 777 levels \"1995-01-01\",\"1995-01-08\",..: 511 712 472 239 273 145 428 694 87 732 ...\n $ Epoch.Date.Close.Approach   : num  NA 1.42e+12 1.21e+12 1.00e+12 1.03e+12 ...\n $ Relative.Velocity.km.per.sec: num  11.22 13.57 5.75 13.84 4.61 ...\n $ Relative.Velocity.km.per.hr : num  40404 48867 20718 49821 16583 ...\n $ Miles.per.hour              : num  25105 30364 12873 30957 10304 ...\n $ Miss.Dist..Astronomical.    : num  NA 0.0671 0.013 0.0583 0.0381 ...\n $ Miss.Dist..lunar.           : num  112.7 26.1 NA 22.7 14.8 ...\n $ Miss.Dist..kilometers.      : num  43348668 10030753 1949933 NA 5694558 ...\n $ Miss.Dist..miles.           : num  26935614 6232821 1211632 5418692 3538434 ...\n $ Orbiting.Body               : Factor w/ 1 level \"Earth\": 1 1 1 1 1 1 1 1 1 1 ...\n $ Orbit.ID                    : int  NA 8 12 12 91 NA 24 NA NA 212 ...\n $ Orbit.Determination.Date    : Factor w/ 2680 levels \"2014-06-13 15:20:44\",..: 69 NA 1377 1774 2275 2554 1919 731 1178 2520 ...\n $ Orbit.Uncertainity          : int  0 8 6 0 0 0 1 1 1 0 ...\n $ Minimum.Orbit.Intersection  : num  NA 0.05594 0.00553 NA 0.0281 ...\n $ Jupiter.Tisserand.Invariant : num  5.58 3.61 4.44 5.5 NA ...\n $ Epoch.Osculation            : num  2457800 2457010 NA 2458000 2458000 ...\n $ Eccentricity                : num  0.276 0.57 0.344 0.255 0.22 ...\n $ Semi.Major.Axis             : num  1.1 NA 1.52 1.11 1.24 ...\n $ Inclination                 : num  20.06 4.39 5.44 23.9 3.5 ...\n $ Asc.Node.Longitude          : num  29.85 1.42 170.68 356.18 183.34 ...\n $ Orbital.Period              : num  419 1040 682 427 503 ...\n $ Perihelion.Distance         : num  0.794 0.864 0.994 0.828 0.965 ...\n $ Perihelion.Arg              : num  41.8 359.3 350 268.2 179.2 ...\n $ Aphelion.Dist               : num  1.4 3.15 2.04 1.39 1.51 ...\n $ Perihelion.Time             : num  2457736 2456941 2457937 NA 2458070 ...\n $ Mean.Anomaly                : num  55.1 NA NA 297.4 310.5 ...\n $ Mean.Motion                 : num  0.859 0.346 0.528 0.843 0.716 ...\n $ Equinox                     : Factor w/ 1 level \"J2000\": 1 1 NA 1 1 1 1 1 1 1 ...\n $ Hazardous                   : int  0 0 0 1 1 0 0 0 1 1 ...\n```\n:::\n:::\n\n\nLet's drop time, name and ID variable and create a classification task:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = nasa %>% select(-Orbit.Determination.Date,\n                       -Close.Approach.Date, -Name, -Neo.Reference.ID)\ndata$Hazardous = as.factor(data$Hazardous)\n\n# Create a classification task.\ntask = TaskClassif$new(id = \"nasa\", backend = data,\n                       target = \"Hazardous\", positive = \"1\")\n```\n:::\n\n\nCreate a generic pipeline of data transformation (imputation $\\rightarrow$ scaling $\\rightarrow$ encoding of categorical variables):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\n# Let's create the preprocessing graph.\npreprocessing = po(\"imputeoor\") %>>% po(\"scale\") %>>% po(\"encode\") \n\n# Run the task.\ntransformed_task = preprocessing$train(task)[[1]]\n\ntransformed_task$missings()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   Hazardous           Absolute.Magnitude \n                        4187                            0 \n               Aphelion.Dist           Asc.Node.Longitude \n                           0                            0 \n                Eccentricity    Epoch.Date.Close.Approach \n                           0                            0 \n            Epoch.Osculation         Est.Dia.in.Feet.max. \n                           0                            0 \n        Est.Dia.in.Feet.min.           Est.Dia.in.KM.max. \n                           0                            0 \n          Est.Dia.in.KM.min.            Est.Dia.in.M.max. \n                           0                            0 \n           Est.Dia.in.M.min.        Est.Dia.in.Miles.max. \n                           0                            0 \n       Est.Dia.in.Miles.min.                  Inclination \n                           0                            0 \n Jupiter.Tisserand.Invariant                 Mean.Anomaly \n                           0                            0 \n                 Mean.Motion               Miles.per.hour \n                           0                            0 \n  Minimum.Orbit.Intersection     Miss.Dist..Astronomical. \n                           0                            0 \n      Miss.Dist..kilometers.            Miss.Dist..lunar. \n                           0                            0 \n           Miss.Dist..miles.                     Orbit.ID \n                           0                            0 \n          Orbit.Uncertainity               Orbital.Period \n                           0                            0 \n              Perihelion.Arg          Perihelion.Distance \n                           0                            0 \n             Perihelion.Time  Relative.Velocity.km.per.hr \n                           0                            0 \nRelative.Velocity.km.per.sec              Semi.Major.Axis \n                           0                            0 \n               Equinox.J2000             Equinox..MISSING \n                           0                            0 \n         Orbiting.Body.Earth       Orbiting.Body..MISSING \n                           0                            0 \n```\n:::\n:::\n\n\nWe can even visualize the preprocessing graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreprocessing$plot()\n```\n\n::: {.cell-output-display}\n![](A4-MLpipeline_files/figure-html/chunk_chapter4_68-1.png){width=672}\n:::\n:::\n\n\nTo test our model (glmnet) with 10-fold cross-validated, we will do:\n\n-   Specify the missing target rows as validation so that they will be ignored.\n-   Specify the cross-validation, the learner (the machine learning model we want to use), and the measurement (AUC).\n-   Run (benchmark) our model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\ntransformed_task$data()[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Hazardous Absolute.Magnitude Aphelion.Dist Asc.Node.Longitude Eccentricity\n      <fctr>              <num>         <num>              <num>        <num>\n1:         0         -0.8132265    -0.3804201          -1.140837    -0.315606\n   Epoch.Date.Close.Approach Epoch.Osculation Est.Dia.in.Feet.max.\n                       <num>            <num>                <num>\n1:                 -4.792988        0.1402677            0.2714179\n   Est.Dia.in.Feet.min. Est.Dia.in.KM.max. Est.Dia.in.KM.min. Est.Dia.in.M.max.\n                  <num>              <num>              <num>             <num>\n1:            0.3134076          0.3007134          0.2565687         0.2710953\n   Est.Dia.in.M.min. Est.Dia.in.Miles.max. Est.Dia.in.Miles.min. Inclination\n               <num>                 <num>                 <num>       <num>\n1:         0.2916245             0.2620443              0.258651   0.5442288\n   Jupiter.Tisserand.Invariant Mean.Anomaly Mean.Motion Miles.per.hour\n                         <num>        <num>       <num>          <num>\n1:                   0.3840868    -1.028761   0.3193953     -0.2541306\n   Minimum.Orbit.Intersection Miss.Dist..Astronomical. Miss.Dist..kilometers.\n                        <num>                    <num>                  <num>\n1:                  -5.459119                -7.076926              0.2512296\n   Miss.Dist..lunar. Miss.Dist..miles.  Orbit.ID Orbit.Uncertainity\n               <num>             <num>     <num>              <num>\n1:         0.2398625         0.2381077 -9.651472          -1.007087\n   Orbital.Period Perihelion.Arg Perihelion.Distance Perihelion.Time\n            <num>          <num>               <num>           <num>\n1:     -0.3013135      -1.170536         -0.01831583       0.1052611\n   Relative.Velocity.km.per.hr Relative.Velocity.km.per.sec Semi.Major.Axis\n                         <num>                        <num>           <num>\n1:                  -0.2816782                   -0.2841407      -0.2791037\n   Equinox.J2000 Equinox..MISSING Orbiting.Body.Earth Orbiting.Body..MISSING\n           <num>            <num>               <num>                  <num>\n1:             1                0                   1                      0\n```\n:::\n\n```{.r .cell-code}\ntransformed_task$set_row_roles((1:nrow(data))[is.na(data$Hazardous)],\n                               \"holdout\")\n\ncv10 = mlr3::rsmp(\"cv\", folds = 10L)\nEN = lrn(\"classif.glmnet\", predict_type = \"prob\")\nmeasurement =  msr(\"classif.auc\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = mlr3::resample(transformed_task,\n                        EN, resampling = cv10, store_models = TRUE)\n\n# Calculate the average AUC of the holdouts.\nresult$aggregate(measurement)\n```\n:::\n\n\nVery cool! Preprocessing + 10-fold cross-validation model evaluation in a few lines of code!\n\nLet's create the final predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred = sapply(1:10, function(i) result$learners[[i]]$predict(transformed_task,\nrow_ids = (1:nrow(data))[is.na(data$Hazardous)])$data$prob[, \"1\", drop = FALSE])\ndim(pred)\npredictions = apply(pred, 1, mean)\n```\n:::\n\n\nYou could now submit the predictions <a href=\"http://rhsbio7.uni-regensburg.de:8500\" target=\"_blank\" rel=\"noopener\">here</a>.\n\nBut we are still not happy with the results, let's do some hyperparameter tuning!\n\n#### mlr3 - Hyperparameter Tuning\n\nWith mlr3, we can easily extend the above example to do hyperparameter tuning within nested cross-validation (the tuning has its own inner cross-validation).\n\nPrint the hyperparameter space of our glmnet learner:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEN$param_set\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<ParamSet>\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Unknown argument 'on' has been passed.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n                      id    class lower upper nlevels\n                  <char>   <char> <num> <num>   <num>\n 1:                alpha ParamDbl     0     1     Inf\n 2:                  big ParamDbl  -Inf   Inf     Inf\n 3:               devmax ParamDbl     0     1     Inf\n 4:                dfmax ParamInt     0   Inf     Inf\n 5:                  eps ParamDbl     0     1     Inf\n 6:                epsnr ParamDbl     0     1     Inf\n 7:                exact ParamLgl    NA    NA       2\n 8:              exclude ParamInt     1   Inf     Inf\n 9:                 exmx ParamDbl  -Inf   Inf     Inf\n10:                 fdev ParamDbl     0     1     Inf\n11:                gamma ParamDbl  -Inf   Inf     Inf\n12:            intercept ParamLgl    NA    NA       2\n13:               lambda ParamUty    NA    NA     Inf\n14:     lambda.min.ratio ParamDbl     0     1     Inf\n15:         lower.limits ParamUty    NA    NA     Inf\n16:                maxit ParamInt     1   Inf     Inf\n17:                mnlam ParamInt     1   Inf     Inf\n18:                 mxit ParamInt     1   Inf     Inf\n19:               mxitnr ParamInt     1   Inf     Inf\n20:            newoffset ParamUty    NA    NA     Inf\n21:              nlambda ParamInt     1   Inf     Inf\n22:               offset ParamUty    NA    NA     Inf\n23:       penalty.factor ParamUty    NA    NA     Inf\n24:                 pmax ParamInt     0   Inf     Inf\n25:                 pmin ParamDbl     0     1     Inf\n26:                 prec ParamDbl  -Inf   Inf     Inf\n27:                relax ParamLgl    NA    NA       2\n28:                    s ParamDbl     0   Inf     Inf\n29:          standardize ParamLgl    NA    NA       2\n30: standardize.response ParamLgl    NA    NA       2\n31:               thresh ParamDbl     0   Inf     Inf\n32:             trace.it ParamInt     0     1       2\n33:        type.gaussian ParamFct    NA    NA       2\n34:        type.logistic ParamFct    NA    NA       2\n35:     type.multinomial ParamFct    NA    NA       2\n36:         upper.limits ParamUty    NA    NA     Inf\n                      id    class lower upper nlevels\n                                                                                      default\n                                                                                       <list>\n 1:                                                                                         1\n 2:                                                                                   9.9e+35\n 3:                                                                                     0.999\n 4: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n 5:                                                                                     1e-06\n 6:                                                                                     1e-08\n 7:                                                                                     FALSE\n 8: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n 9:                                                                                       250\n10:                                                                                     1e-05\n11:                                                                                         1\n12:                                                                                      TRUE\n13: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n14: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n15: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n16:                                                                                    100000\n17:                                                                                         5\n18:                                                                                       100\n19:                                                                                        25\n20: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n21:                                                                                       100\n22:                                                                                          \n23: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n24: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n25:                                                                                     1e-09\n26:                                                                                     1e-10\n27:                                                                                     FALSE\n28:                                                                                      0.01\n29:                                                                                      TRUE\n30:                                                                                     FALSE\n31:                                                                                     1e-07\n32:                                                                                         0\n33: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n34: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n35: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n36: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n                                                                                      default\n    parents  value\n     <list> <list>\n 1:               \n 2:               \n 3:               \n 4:               \n 5:               \n 6:               \n 7:               \n 8:               \n 9:               \n10:               \n11:   relax       \n12:               \n13:               \n14:               \n15:               \n16:               \n17:               \n18:               \n19:               \n20:               \n21:               \n22:               \n23:               \n24:               \n25:               \n26:               \n27:               \n28:               \n29:               \n30:               \n31:               \n32:               \n33:               \n34:               \n35:               \n36:               \n    parents  value\n```\n:::\n:::\n\n\nDefine the hyperparameter space of the random forest:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(paradox)\n\nEN_pars = \n    paradox::ParamSet$new(\n      list(paradox::ParamDbl$new(\"alpha\", lower = 0, upper = 1L),\n           paradox::ParamDbl$new(\"lambda\", lower = 0, upper = 0.5 )) )\nprint(EN_pars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<ParamSet>\n       id    class lower upper nlevels\n   <char>   <char> <num> <num>   <num>\n1:  alpha ParamDbl     0   1.0     Inf\n2: lambda ParamDbl     0   0.5     Inf\n                                                                                     default\n                                                                                      <list>\n1: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n2: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n    value\n   <list>\n1:       \n2:       \n```\n:::\n:::\n\n\nTo set up the tuning pipeline we need:\n\n-   Inner cross-validation resampling object.\n-   Tuning criterion (e.g. AUC).\n-   Tuning method (e.g. random or block search).\n-   Tuning terminator (When should we stop tuning? E.g. after $n$ iterations).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\ninner3 = mlr3::rsmp(\"cv\", folds = 3L)\nmeasurement =  msr(\"classif.auc\")\ntuner =  mlr3tuning::tnr(\"random_search\") \nterminator = mlr3tuning::trm(\"evals\", n_evals = 5L)\nEN = lrn(\"classif.glmnet\", predict_type = \"prob\")\n\nlearner_tuner = AutoTuner$new(learner = EN, \n                              measure = measurement, \n                              tuner = tuner, \n                              terminator = terminator,\n                              search_space = EN_pars,\n                              resampling = inner3)\nprint(learner_tuner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<AutoTuner:classif.glmnet.tuned>\n* Model: list\n* Search Space:\n<ParamSet>\n       id    class lower upper nlevels\n   <char>   <char> <num> <num>   <num>\n1:  alpha ParamDbl     0   1.0     Inf\n2: lambda ParamDbl     0   0.5     Inf\n                                                                                     default\n                                                                                      <list>\n1: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n2: <NoDefault>\\n  Public:\\n    clone: function (deep = FALSE) \\n    initialize: function () \n    value\n   <list>\n1:       \n2:       \n* Packages: mlr3, mlr3tuning, mlr3learners, glmnet\n* Predict Type: prob\n* Feature Types: logical, integer, numeric\n* Properties: multiclass, twoclass, weights\n```\n:::\n:::\n\n\nNow we can wrap it normally into the 10-fold cross-validated setup as done previously:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate the average AUC of the holdouts.\nresult$aggregate(measurement)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclassif.auc \n  0.6767554 \n```\n:::\n:::\n\n\nLet's create the final predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred = sapply(1:3, function(i) result$learners[[i]]$predict(transformed_task,\nrow_ids = (1:nrow(data))[is.na(data$Hazardous)])$data$prob[, \"1\", drop = FALSE])\ndim(pred)\npredictions = apply(pred, 1, mean)\n```\n:::\n\n\n## Exercises\n\n### Tuning Regularization\n\n::: callout-warning\n#### Question: Hyperparameter tuning - Titanic dataset\n\nTune architecture\n\n-   Tune training parameters (learning rate, batch size) and regularization\n\n**Hints**\n\ncito has a feature to automatically tune hyperparameters under Cross Validation!\n\n-   passing `tune(...)` to a hyperparameter will tell cito to tune this specific hyperparameter\n-   the `tuning = config_tuning(...)` let you specify the cross-validation strategy and the number of hyperparameters that should be tested (steps = number of hyperparameter combinations that should be tried)\n-   after tuning, cito will fit automatically a model with the best hyperparameters on the full data and will return this model\n\nMinimal example with the iris dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cito)\ndf = iris\ndf[,1:4] = scale(df[,1:4])\n\nmodel_tuned = dnn(Species~., \n                  loss = \"softmax\",\n                  data = iris,\n                  lambda = tune(lower = 0.0, upper = 0.2), # you can pass the \"tune\" function to a hyerparameter\n                  tuning = config_tuning(CV = 3, steps = 20L)\n                  )\n\n# tuning results\nmodel_tuned$tuning\n\n\n# model_tuned is now already the best model!\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\nlibrary(dplyr)\nlibrary(missRanger)\ndata(titanic_ml)\ndata = titanic_ml\ndata = \n  data %>% select(survived, sex, age, fare, pclass)\ndata[,-1] = missRanger(data[,-1], verbose = 0)\n\ndata_sub =\n  data %>%\n    mutate(age = scales::rescale(age, c(0, 1)),\n           fare = scales::rescale(fare, c(0, 1))) %>%\n    mutate(sex = as.integer(sex) - 1L,\n           pclass = as.integer(pclass - 1L))\ndata_new = data_sub[is.na(data_sub$survived),] # for which we want to make predictions at the end\ndata_obs = data_sub[!is.na(data_sub$survived),] # data with known response\n\n\nmodel = dnn(survived~., \n          hidden = c(10L, 10L), # change\n          activation = c(\"selu\", \"selu\"), # change\n          loss = \"binomial\", \n          lr = 0.05, #change\n          validation = 0.2,\n          lambda = 0.001, # change\n          alpha = 0.1, # change\n          lr_scheduler = config_lr_scheduler(\"reduce_on_plateau\", patience = 10, factor = 0.9),\n          data = data_obs, epochs = 40L, verbose = TRUE, plot= TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLoss at epoch 1: training: 0.695, validation: 0.687, lr: 0.05000\n```\n:::\n\n::: {.cell-output-display}\n![](A4-MLpipeline_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nLoss at epoch 2: training: 0.629, validation: 0.761, lr: 0.05000\nLoss at epoch 3: training: 0.618, validation: 0.690, lr: 0.05000\nLoss at epoch 4: training: 0.588, validation: 0.530, lr: 0.05000\nLoss at epoch 5: training: 0.577, validation: 0.592, lr: 0.05000\nLoss at epoch 6: training: 0.558, validation: 0.668, lr: 0.05000\nLoss at epoch 7: training: 0.554, validation: 0.520, lr: 0.05000\nLoss at epoch 8: training: 0.559, validation: 0.476, lr: 0.05000\nLoss at epoch 9: training: 0.564, validation: 0.469, lr: 0.05000\nLoss at epoch 10: training: 0.567, validation: 0.585, lr: 0.05000\nLoss at epoch 11: training: 0.523, validation: 0.449, lr: 0.05000\nLoss at epoch 12: training: 0.507, validation: 0.540, lr: 0.05000\nLoss at epoch 13: training: 0.526, validation: 0.552, lr: 0.05000\nLoss at epoch 14: training: 0.518, validation: 0.618, lr: 0.05000\nLoss at epoch 15: training: 0.494, validation: 0.517, lr: 0.05000\nLoss at epoch 16: training: 0.490, validation: 0.623, lr: 0.05000\nLoss at epoch 17: training: 0.490, validation: 0.581, lr: 0.05000\nLoss at epoch 18: training: 0.465, validation: 0.394, lr: 0.05000\nLoss at epoch 19: training: 0.604, validation: 0.528, lr: 0.05000\nLoss at epoch 20: training: 0.477, validation: 0.960, lr: 0.05000\nLoss at epoch 21: training: 0.492, validation: 0.479, lr: 0.05000\nLoss at epoch 22: training: 0.533, validation: 0.626, lr: 0.05000\nLoss at epoch 23: training: 0.475, validation: 0.425, lr: 0.05000\nLoss at epoch 24: training: 0.490, validation: 0.540, lr: 0.05000\nLoss at epoch 25: training: 0.481, validation: 0.581, lr: 0.05000\nLoss at epoch 26: training: 0.488, validation: 0.451, lr: 0.05000\nLoss at epoch 27: training: 0.467, validation: 0.473, lr: 0.05000\nLoss at epoch 28: training: 0.470, validation: 0.391, lr: 0.05000\nLoss at epoch 29: training: 0.466, validation: 0.382, lr: 0.05000\nLoss at epoch 30: training: 0.471, validation: 0.387, lr: 0.05000\nLoss at epoch 31: training: 0.487, validation: 0.468, lr: 0.05000\nLoss at epoch 32: training: 0.467, validation: 0.384, lr: 0.05000\nLoss at epoch 33: training: 0.489, validation: 0.389, lr: 0.05000\nLoss at epoch 34: training: 0.485, validation: 0.774, lr: 0.05000\nLoss at epoch 35: training: 0.533, validation: 0.392, lr: 0.05000\nLoss at epoch 36: training: 0.528, validation: 0.401, lr: 0.05000\nLoss at epoch 37: training: 0.494, validation: 0.510, lr: 0.05000\nLoss at epoch 38: training: 0.516, validation: 0.871, lr: 0.05000\nLoss at epoch 39: training: 0.478, validation: 0.368, lr: 0.05000\nLoss at epoch 40: training: 0.509, validation: 0.756, lr: 0.05000\n```\n:::\n\n```{.r .cell-code}\n# Predictions:\n\npredictions = predict(model, newdata = data_new, type = \"response\") # change prediction type to response so that cito predicts probabilities\n\nwrite.csv(data.frame(y = predictions[,1]), file = \"Max_titanic_dnn.csv\")\n```\n:::\n\n:::\n\n<!-- ::: {.callout-warning} -->\n\n<!-- #### Task: Tuning $\\alpha$ and $\\lambda$ -->\n\n<!-- 1.  Extend the code from above and tune $\\alpha$ and $\\lambda$ (via 10xCV) -->\n\n<!-- 2.  Train the model with best set of hyperparameters and submit your predictions -->\n\n<!-- Submit your predictions (<http://rhsbio7.uni-regensburg.de:8500/>), which model has a higher AUC?. -->\n\n<!-- **Important**: -->\n\n<!-- Submissions only work if your preditions are probabilities and a data.frame (which you can create via `write.csv(data.frame(y = predictions ), file = \"Max_1.csv\")` -->\n\n<!--  ) -->\n\n<!-- ```{r} -->\n\n<!-- library(EcoData) -->\n\n<!-- library(dplyr) -->\n\n<!-- library(missRanger) -->\n\n<!-- library(glmnet) -->\n\n<!-- library(glmnetUtils) -->\n\n<!-- data(titanic_ml) -->\n\n<!-- data = titanic_ml -->\n\n<!-- data =  -->\n\n<!--   data %>% select(survived, sex, age, fare, pclass) -->\n\n<!-- # missRanger uses a random forest to impute NAs (RF is trained on the data to predict values for the NAs) -->\n\n<!-- data[,-1] = missRanger(data[,-1], verbose = 0) -->\n\n<!-- data_sub = -->\n\n<!--   data %>% -->\n\n<!--     mutate(age = scales::rescale(age, c(0, 1)), -->\n\n<!--            fare = scales::rescale(fare, c(0, 1))) %>% -->\n\n<!--     mutate(sex = as.integer(sex) - 1L, -->\n\n<!--            pclass = as.integer(pclass - 1L)) -->\n\n<!-- data_new = data_sub[is.na(data_sub$survived),] # for which we want to make predictions at the end -->\n\n<!-- data_obs = data_sub[!is.na(data_sub$survived),] # data with known response -->\n\n<!-- ``` -->\n\n<!-- Bonus: -->\n\n<!-- -   Try different features -->\n\n<!-- -   Try cito -->\n\n<!-- -   Try different datasets (see @sec-datasets) -->\n\n<!-- Code template for a simple CV (for tuning $\\lambda$): -->\n\n<!-- - Extend the following code so that $\\alpha$ is also tuned! -->\n\n<!-- ```{r} -->\n\n<!-- set.seed(42) -->\n\n<!-- cv = 5 -->\n\n<!-- hyper_lambda = runif(20,0, 0.2) -->\n\n<!-- tuning_results =  -->\n\n<!--     sapply(1:length(hyper_lambda), function(k) { -->\n\n<!--         auc_inner = NULL -->\n\n<!--         for(j in 1:cv) { -->\n\n<!--           inner_split = as.integer(cut(1:nrow(data_obs), breaks = cv)) -->\n\n<!--           train_inner = data_obs[inner_split != j, ] -->\n\n<!--           test_inner = data_obs[inner_split == j, ] -->\n\n<!--           model = glmnet(survived~.,data = train_inner, lambda = hyper_lambda[k], family = \"binomial\") -->\n\n<!--           auc_inner[j]= Metrics::auc(test_inner$survived, predict(model, test_inner, type = \"response\")) -->\n\n<!--         } -->\n\n<!--       return(mean(auc_inner)) -->\n\n<!--     }) -->\n\n<!-- results = data.frame(lambda = hyper_lambda, AUC = tuning_results) -->\n\n<!-- print(results) -->\n\n<!-- ``` -->\n\n<!-- ::: -->\n\n<!-- \n<div class='webex-solution'><button>Click here to see the solution</button>\n -->\n\n<!-- ```{r} -->\n\n<!-- set.seed(42) -->\n\n<!-- cv = 5 -->\n\n<!-- hyper_lambda = runif(20,0, 0.2) -->\n\n<!-- hyper_alpha = runif(20, 0, 1) -->\n\n<!-- tuning_results =  -->\n\n<!--     sapply(1:length(hyper_alpha), function(k) { -->\n\n<!--         auc_inner = NULL -->\n\n<!--         for(j in 1:cv) { -->\n\n<!--           inner_split = as.integer(cut(1:nrow(data_obs), breaks = cv)) -->\n\n<!--           train_inner = data_obs[inner_split != j, ] -->\n\n<!--           test_inner = data_obs[inner_split == j, ] -->\n\n<!--           model = glmnet(survived~.,data = train_inner, family = \"binomial\", alpha = hyper_alpha[k], lambda = hyper_lambda[k]) -->\n\n<!--           auc_inner[j]= Metrics::auc(test_inner$survived, predict(model, test_inner, type = \"response\")) -->\n\n<!--         } -->\n\n<!--       return(mean(auc_inner)) -->\n\n<!--     }) -->\n\n<!-- results = data.frame(lambda = hyper_lambda, alpha = hyper_alpha,  AUC = tuning_results) -->\n\n<!-- print(results) -->\n\n<!-- print(results[which.max(results$AUC),]) -->\n\n<!-- ``` -->\n\n<!-- Predictions: -->\n\n<!-- ```{r, results='hide', message=FALSE, warning=FALSE} -->\n\n<!-- model = glmnet(survived~.,data = data_obs, family = \"binomial\",alpha = results[which.max(results$AUC),2]) -->\n\n<!-- predictions = predict(model, data_new, alpha = results$alpha[i], s = results[which.max(results$AUC),1], type = \"response\")[,1] -->\n\n<!-- write.csv(data.frame(y = predictions, file = \"Max_titanic_best_model.csv\")) -->\n\n<!-- ``` -->\n\n<!-- \n</div>\n -->\n\n### Bonus: mlr3\n\n::: callout-warning\n#### Task: Use mlr3 for the titanic dataset\n\n1.  Use `mlr3` to tune glmnet for the titanic dataset using nested CV\n2.  Submit single predictions and multiple predictions\n\nIf you need help, take a look at the solution, go through it line by line and try to understand it.\n:::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\nPrepare data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = titanic_ml %>% select(-name, -ticket, -name, -body)\ndata$pclass = as.factor(data$pclass)\ndata$sex = as.factor(data$sex)\ndata$survived = as.factor(data$survived)\n\n# Change easy things manually:\ndata$embarked[data$embarked == \"\"] = \"S\"  # Fill in \"empty\" values.\ndata$embarked = droplevels(as.factor(data$embarked)) # Remove unused levels (\"\").\ndata$cabin = (data$cabin != \"\") * 1 # Dummy code the availability of a cabin.\ndata$fare[is.na(data$fare)] = mean(data$fare, na.rm = TRUE)\nlevels(data$home.dest)[levels(data$home.dest) == \"\"] = \"unknown\"\nlevels(data$boat)[levels(data$boat) == \"\"] = \"none\"\n\n# Create a classification task.\ntask = TaskClassif$new(id = \"titanic\", backend = data,\n                       target = \"survived\", positive = \"1\")\ntask$missings()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n survived       age      boat     cabin  embarked      fare home.dest     parch \n      655       263         0         0         0         0         0         0 \n   pclass       sex     sibsp \n        0         0         0 \n```\n:::\n\n```{.r .cell-code}\n# Let's create the preprocessing graph.\npreprocessing = po(\"imputeoor\") %>>% po(\"scale\") %>>% po(\"encode\") \n\n# Run the task.\ntransformed_task = preprocessing$train(task)[[1]]\n\ntransformed_task$set_row_roles((1:nrow(data))[is.na(data$survived)], \"holdout\")\n```\n:::\n\n\nHyperparameter tuning:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv10 = mlr3::rsmp(\"cv\", folds = 10L)\n\ninner3 = mlr3::rsmp(\"cv\", folds = 3L)\nmeasurement =  msr(\"classif.auc\")\ntuner =  mlr3tuning::tnr(\"random_search\") \nterminator = mlr3tuning::trm(\"evals\", n_evals = 5L)\nEN = lrn(\"classif.glmnet\", predict_type = \"prob\")\nEN_pars = \n    paradox::ParamSet$new(\n      list(paradox::ParamDbl$new(\"alpha\", lower = 0, upper = 1L),\n           paradox::ParamDbl$new(\"lambda\", lower = 0, upper = 0.5 )) )\n\nlearner_tuner = AutoTuner$new(learner = EN, \n                              measure = measurement, \n                              tuner = tuner, \n                              terminator = terminator,\n                              search_space = EN_pars,\n                              resampling = inner3)\n\n\nresult = mlr3::resample(transformed_task, learner_tuner,\n                        resampling = cv10, store_models = TRUE)\n```\n:::\n\n\nEvaluation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeasurement =  msr(\"classif.auc\")\nresult$aggregate(measurement)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclassif.auc \n  0.9939211 \n```\n:::\n:::\n\n\nPredictions:\n\nWe can extract a learner with optimized hyperparameters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = result$learners[[1]]$learner$clone()\nmodel$param_set$values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$alpha\n[1] 0.1832108\n\n$lambda\n[1] 0.1246408\n```\n:::\n:::\n\n\nAnd we can fit it then on the full data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel$train(transformed_task)\npredictions = model$predict(transformed_task, row_ids = transformed_task$row_roles$holdout)\npredictions = predictions$prob[,1]\nhead(predictions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8555042 0.1554276 0.3219091 0.7343347 0.8628420 0.8735773\n```\n:::\n:::\n\n\nAnd submit to http://rhsbio7.uni-regensburg.de:8500\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(data.frame(y = predictions), file = \"glmnet.csv\")\n```\n:::\n\n\n\n</div>\n\n",
    "supporting": [
      "A4-MLpipeline_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}