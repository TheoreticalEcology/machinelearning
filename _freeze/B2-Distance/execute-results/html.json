{
  "hash": "615bf54c219805eb412fd60a16449e12",
  "result": {
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n# Distance-based Algorithms\n\nIn this chapter, we introduce support-vector machines (SVMs) and other distance-based methods **Hint**: Distance-based models need scaling!\n\n## K-Nearest-Neighbor\n\nK-nearest-neighbor (kNN) is a simple algorithm that stores all the available cases and classifies the new data based on a similarity measure. It is mostly used to classify a data point based on how its $k$ nearest neighbors are classified.\n\nLet us first see an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = scale(iris[,1:4])\ny = iris[,5]\nplot(x[-100,1], x[-100, 3], col = y)\npoints(x[100,1], x[100, 3], col = \"blue\", pch = 18, cex = 1.3)\n```\n\n::: {.cell-output-display}\n![](B2-Distance_files/figure-html/chunk_chapter4_32-1.png){width=672}\n:::\n:::\n\n\nWhich class would you decide for the blue point? What are the classes of the nearest points? Well, this procedure is used by the k-nearest-neighbors classifier and thus there is actually no \"real\" learning in a k-nearest-neighbors classification.\n\nFor applying a k-nearest-neighbors classification, we first have to scale the data set, because we deal with distances and want the same influence of all predictors. Imagine one variable has values from -10.000 to 10.000 and another from -1 to 1. Then the influence of the first variable on the distance to the other points is much stronger than the influence of the second variable. On the iris data set, we have to split the data into training and test set on our own. Then we will follow the usual pipeline.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = iris\ndata[,1:4] = apply(data[,1:4],2, scale)\nindices = sample.int(nrow(data), 0.7*nrow(data))\ntrain = data[indices,]\ntest = data[-indices,]\n```\n:::\n\n\nFit model and create predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(kknn)\nset.seed(123)\n\nknn = kknn(Species~., train = train, test = test)\nsummary(knn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nkknn(formula = Species ~ ., train = train, test = test)\n\nResponse: \"nominal\"\n          fit prob.setosa prob.versicolor prob.virginica\n1      setosa           1       0.0000000      0.0000000\n2      setosa           1       0.0000000      0.0000000\n3      setosa           1       0.0000000      0.0000000\n4      setosa           1       0.0000000      0.0000000\n5      setosa           1       0.0000000      0.0000000\n6      setosa           1       0.0000000      0.0000000\n7      setosa           1       0.0000000      0.0000000\n8      setosa           1       0.0000000      0.0000000\n9      setosa           1       0.0000000      0.0000000\n10     setosa           1       0.0000000      0.0000000\n11     setosa           1       0.0000000      0.0000000\n12     setosa           1       0.0000000      0.0000000\n13     setosa           1       0.0000000      0.0000000\n14     setosa           1       0.0000000      0.0000000\n15 versicolor           0       0.9843084      0.0156916\n16 versicolor           0       1.0000000      0.0000000\n17 versicolor           0       1.0000000      0.0000000\n18 versicolor           0       1.0000000      0.0000000\n19 versicolor           0       1.0000000      0.0000000\n20  virginica           0       0.4482986      0.5517014\n21 versicolor           0       1.0000000      0.0000000\n22 versicolor           0       1.0000000      0.0000000\n23 versicolor           0       1.0000000      0.0000000\n24 versicolor           0       1.0000000      0.0000000\n25  virginica           0       0.0000000      1.0000000\n26 versicolor           0       0.7783044      0.2216956\n27  virginica           0       0.1339415      0.8660585\n28  virginica           0       0.1008186      0.8991814\n29  virginica           0       0.0156916      0.9843084\n30  virginica           0       0.0000000      1.0000000\n31  virginica           0       0.0000000      1.0000000\n32  virginica           0       0.1257844      0.8742156\n33 versicolor           0       0.8742156      0.1257844\n34  virginica           0       0.0000000      1.0000000\n35  virginica           0       0.3569042      0.6430958\n36  virginica           0       0.4420312      0.5579688\n37  virginica           0       0.0000000      1.0000000\n38 versicolor           0       0.6931774      0.3068226\n39  virginica           0       0.0000000      1.0000000\n40  virginica           0       0.1885727      0.8114273\n41  virginica           0       0.0000000      1.0000000\n42  virginica           0       0.0000000      1.0000000\n43  virginica           0       0.4934627      0.5065373\n44  virginica           0       0.0000000      1.0000000\n45  virginica           0       0.2373872      0.7626128\n```\n:::\n\n```{.r .cell-code}\ntable(test$Species, fitted(knn))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            \n             setosa versicolor virginica\n  setosa         14          0         0\n  versicolor      0          9         1\n  virginica       0          3        18\n```\n:::\n:::\n\n\n## Support Vector Machines (SVMs)\n\nSupport vectors machines have a different approach. They try to divide the predictor space into sectors for each class. To do so, a support-vector machine fits the parameters of a hyperplane (a $n-1$ dimensional subspace in a $n$-dimensional space) in the predictor space by optimizing the distance between the hyperplane and the nearest point from each class.\n\nFitting a support-vector machine:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(e1071)\n\ndata = iris\ndata[,1:4] = apply(data[,1:4], 2, scale)\nindices = sample.int(nrow(data), 0.7*nrow(data))\ntrain = data[indices,]\ntest = data[-indices,]\n\nsm = svm(Species~., data = train, kernel = \"linear\")\npred = predict(sm, newdata = test)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noldpar = par(mfrow = c(1, 2))\nplot(test$Sepal.Length, test$Petal.Length,\n     col =  pred, main = \"predicted\")\nplot(test$Sepal.Length, test$Petal.Length,\n     col =  test$Species, main = \"observed\")\n```\n\n::: {.cell-output-display}\n![](B2-Distance_files/figure-html/chunk_chapter4_36-1.png){width=672}\n:::\n\n```{.r .cell-code}\npar(oldpar)\n\nmean(pred == test$Species) # Accuracy.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9777778\n```\n:::\n:::\n\n\nSupport-vector machines can only work on linearly separable problems. (A problem is called linearly separable if there exists at least one line in the plane with all of the points of one class on one side of the hyperplane and all the points of the others classes on the other side).\n\nIf this is not possible, we however, can use the so called *kernel trick*, which maps the predictor space into a (higher dimensional) space in which the problem is linear separable. After having identified the boundaries in the higher-dimensional space, we can project them back into the original dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 = seq(-3, 3, length.out = 100)\nx2 = seq(-3, 3, length.out = 100)\nX = expand.grid(x1, x2)\ny = apply(X, 1, function(t) exp(-t[1]^2 - t[2]^2))\ny = ifelse(1/(1+exp(-y)) < 0.62, 0, 1)\n\nimage(matrix(y, 100, 100))\nanimation::saveGIF(\n  {\n    for(i in c(\"truth\", \"linear\", \"radial\", \"sigmoid\")){\n      if(i == \"truth\"){\n        image(matrix(y, 100,100),\n        main = \"Ground truth\", axes = FALSE, las = 2)\n      }else{\n        sv = e1071::svm(x = x, y = factor(y), kernel = i)\n        image(matrix(as.numeric(as.character(predict(sv, x))), 100, 100),\n        main = paste0(\"Kernel: \", i), axes = FALSE, las = 2)\n        axis(1, at = seq(0,1, length.out = 10),\n        labels = round(seq(-3, 3, length.out = 10), 1))\n        axis(2, at = seq(0,1, length.out = 10),\n        labels = round(seq(-3, 3, length.out = 10), 1), las = 2)\n      }\n    }\n  },\n  movie.name = \"svm.gif\", autobrowse = FALSE, interval = 2\n)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](./images/svm.gif)\n:::\n:::\n\n\nAs you have seen, this does not work with every kernel. Hence, the problem is to find the actual correct kernel, which is again an optimization procedure and can thus be approximated.\n\n## Exercises\n\n::: {.callout-caution icon=\"false\"}\n#### Question: Hyperparameter tuning of kNN\n\nCombing back to the titanic dataset from the morning, we want to optimize the number of neighbors (k) and the kernel of the kNN:\n\nPrepare the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(missRanger)\ndata(titanic_ml)\ndata = titanic_ml\ndata = \n  data %>% select(survived, sex, age, fare, pclass)\ndata[,-1] = missRanger(data[,-1], verbose = 0)\n\ndata_sub =\n  data %>%\n    mutate(age = scales::rescale(age, c(0, 1)),\n           fare = scales::rescale(fare, c(0, 1))) %>%\n    mutate(sex = as.integer(sex) - 1L,\n           pclass = as.integer(pclass - 1L))\ndata_new = data_sub[is.na(data_sub$survived),] # for which we want to make predictions at the end\ndata_obs = data_sub[!is.na(data_sub$survived),] # data with known response\n```\n:::\n\n\n**Hints:**\n\n-   check the help of the kNN function to get an idea about the hyperparameters\n\n::: {.callout-tip collapse=\"true\" appearance=\"minimal\"}\n## Code template\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(kknn)\nset.seed(42)\ndata_obs = data_sub[!is.na(data_sub$survived),] \ncv = 3\n\nouter_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n\nhyper_k = ... # must be integer vector\nhyper_kernel = ... # must be character vector\n\nresults = data.frame(\n  set = rep(NA, cv),\n  k = rep(NA, cv),\n  kernel = rep(NA, cv),\n  AUC = rep(NA, cv)\n)\n\nfor(i in 1:cv) {\n  train_outer = data_obs[outer_split != i, ]\n  test_outer = data_obs[outer_split == i, ]\n  \n  tuning_results = \n      sapply(1:length(hyper_k), function(k) {\n        predictions = kknn(as.factor(survived)~., train = train_outer, test = test_outer, k = hyper_k[k], scale = FALSE, kernel = hyper_kernel[k])\n        return(Metrics::auc(test_outer$survived, predictions$prob[,2]))\n      })\n  \n  results[i, 1] = i\n  results[i, 2] = hyper_k[which.max(tuning_results)]\n  results[i, 3] = hyper_kernel[which.max(tuning_results)]  \n  results[i, 4] = max(tuning_results)\n}\n\nprint(results)\n```\n:::\n\n:::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(kknn)\nset.seed(42)\ndata_obs = data_sub[!is.na(data_sub$survived),] \ncv = 3\n\nouter_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n\n# sample minnodesize values (must be integers)\nhyper_k = sample(10, 10)\nhyper_kernel = sample(c(\"triangular\", \"inv\", \"gaussian\", \"rank\"), 10, replace = TRUE)\n\nresults = data.frame(\n  set = rep(NA, cv),\n  k = rep(NA, cv),\n  kernel = rep(NA, cv),\n  AUC = rep(NA, cv)\n)\n\nfor(i in 1:cv) {\n  train_outer = data_obs[outer_split != i, ]\n  test_outer = data_obs[outer_split == i, ]\n  \n  tuning_results = \n      sapply(1:length(hyper_k), function(k) {\n        predictions = kknn(as.factor(survived)~., train = train_outer, test = test_outer, k = hyper_k[k], scale = FALSE, kernel = hyper_kernel[k])\n        return(Metrics::auc(test_outer$survived, predictions$prob[,2]))\n      })\n  \n  results[i, 1] = i\n  results[i, 2] = hyper_k[which.max(tuning_results)]\n  results[i, 3] = hyper_kernel[which.max(tuning_results)]  \n  results[i, 4] = max(tuning_results)\n}\n\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  set  k   kernel       AUC\n1   1 10 gaussian 0.8149876\n2   2  9     rank 0.8080321\n3   3  6      inv 0.8290219\n```\n:::\n:::\n\n\nMake predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction_ensemble = \n  sapply(1:nrow(results), function(i) {\n    predictions = kknn(as.factor(survived)~., train = data_obs, test = data_new, k = results$k[i], scale = FALSE, kernel = results$kernel[i])\n    return(predictions$prob[,2])\n  })\n\n# Single predictions from the ensemble model:\nwrite.csv(data.frame(y = apply(prediction_ensemble, 1, mean)), file = \"Max_titanic_ensemble.csv\")\n```\n:::\n\n\n\n</div>\n\n:::\n\n\n::: {.callout-caution icon=\"false\"}\n#### Question: kNN and SVM\n\nFit a standard k-nearest-neighbor classifier and a support vector machine with a linear kernel (check help) on the Sonar dataset, and report what fitted better.\n\nPrepare dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlbench)\nset.seed(123)\n\ndata(Sonar)\ndata = Sonar\n#str(data)\n\n# Do not forget scaling! This may be done implicitly by most functions.\n# Here, it's done explicitly for teaching purposes.\ndata = cbind.data.frame(\n  scale(data[,-length(data)]),\n  \"class\" = data[,length(data)]\n)\n\nn = length(data[,1])\nindicesTrain = sample.int(n, (n+1) %/% 2) # Take (at least) 50 % of the data.\n\ntrain = data[indicesTrain,]\ntest = data[-indicesTrain,]\n```\n:::\n\n\n**Tasks:**\n\n-   Fit a svm (from the e1071 package) on the train dataset and make predictions for the test dataset\n-   Fit a kNN (from the kknn package) on the train dataset and make predictions for the test dataset\n-   Calculate confusion matrices to compare the performance\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(e1071)\nlibrary(kknn)\n\nknn = kknn(class~., train = train, test = test, scale = FALSE,\n           kernel = \"rectangular\")\npredKNN = predict(knn, newdata = test)\n\nsm = svm(class~., data = train, scale = FALSE, kernel = \"linear\")\npredSVM = predict(sm, newdata = test)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nK-nearest-neighbor, standard (rectangular) kernel:\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n       labelsTest\npredKNN  M  R\n      M 46 29\n      R  8 21\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nCorrectly classified:  67  /  104\n```\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nSupport-vector machine, linear kernel:\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n       labelsTest\npredSVM  M  R\n      M 41 15\n      R 13 35\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nCorrectly classified:  76  /  104\n```\n:::\n:::\n\n\nK-nearest neighbor fitted (slightly) better.\n\n\n</div>\n\n:::\n\n",
    "supporting": [
      "B2-Distance_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}