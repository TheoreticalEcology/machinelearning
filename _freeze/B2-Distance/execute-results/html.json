{
  "hash": "a6d205e75542e298a37252ef65ac03a0",
  "result": {
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n# Distance-based Algorithms\n\nIn this chapter, we introduce support-vector machines (SVMs) and other distance-based methods\n**Hint**: Distance-based models need scaling!\n\n## K-Nearest-Neighbor\n\nK-nearest-neighbor (kNN) is a simple algorithm that stores all the available cases and classifies the new data based on a similarity measure. It is mostly used to classify a data point based on how its $k$ nearest neighbors are classified.\n\nLet us first see an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = scale(iris[,1:4])\ny = iris[,5]\nplot(x[-100,1], x[-100, 3], col = y)\npoints(x[100,1], x[100, 3], col = \"blue\", pch = 18, cex = 1.3)\n```\n\n::: {.cell-output-display}\n![](B2-Distance_files/figure-html/chunk_chapter4_32-1.png){width=672}\n:::\n:::\n\n\nWhich class would you decide for the blue point? What are the classes of the nearest points? Well, this procedure is used by the k-nearest-neighbors classifier and thus there is actually no \"real\" learning in a k-nearest-neighbors classification.\n\nFor applying a k-nearest-neighbors classification, we first have to scale the data set, because we deal with distances and want the same influence of all predictors. Imagine one variable has values from -10.000 to 10.000 and another from -1 to 1. Then the influence of the first variable on the distance to the other points is much stronger than the influence of the second variable.\nOn the iris data set, we have to split the data into training and test set on our own. Then we will follow the usual pipeline. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = iris\ndata[,1:4] = apply(data[,1:4],2, scale)\nindices = sample.int(nrow(data), 0.7*nrow(data))\ntrain = data[indices,]\ntest = data[-indices,]\n```\n:::\n\n\nFit model and create predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(kknn)\nset.seed(123)\n\nknn = kknn(Species~., train = train, test = test)\nsummary(knn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nkknn(formula = Species ~ ., train = train, test = test)\n\nResponse: \"nominal\"\n          fit prob.setosa prob.versicolor prob.virginica\n1      setosa   1.0000000      0.00000000     0.00000000\n2      setosa   1.0000000      0.00000000     0.00000000\n3      setosa   1.0000000      0.00000000     0.00000000\n4      setosa   1.0000000      0.00000000     0.00000000\n5      setosa   1.0000000      0.00000000     0.00000000\n6      setosa   1.0000000      0.00000000     0.00000000\n7      setosa   1.0000000      0.00000000     0.00000000\n8      setosa   1.0000000      0.00000000     0.00000000\n9      setosa   1.0000000      0.00000000     0.00000000\n10     setosa   1.0000000      0.00000000     0.00000000\n11     setosa   0.7013345      0.29866548     0.00000000\n12     setosa   1.0000000      0.00000000     0.00000000\n13     setosa   1.0000000      0.00000000     0.00000000\n14 versicolor   0.0000000      0.95118552     0.04881448\n15 versicolor   0.0000000      0.76888014     0.23111986\n16 versicolor   0.0000000      1.00000000     0.00000000\n17 versicolor   0.0000000      0.91487300     0.08512700\n18 versicolor   0.0000000      1.00000000     0.00000000\n19 versicolor   0.0000000      1.00000000     0.00000000\n20  virginica   0.0000000      0.34747996     0.65252004\n21  virginica   0.0000000      0.49084569     0.50915431\n22 versicolor   0.0000000      0.89918140     0.10081860\n23 versicolor   0.0000000      1.00000000     0.00000000\n24 versicolor   0.0000000      1.00000000     0.00000000\n25 versicolor   0.0000000      1.00000000     0.00000000\n26 versicolor   0.0000000      1.00000000     0.00000000\n27 versicolor   0.0000000      0.91487300     0.08512700\n28 versicolor   0.0000000      1.00000000     0.00000000\n29 versicolor   0.0000000      1.00000000     0.00000000\n30  virginica   0.0000000      0.00000000     1.00000000\n31 versicolor   0.0000000      0.87421565     0.12578435\n32  virginica   0.0000000      0.00000000     1.00000000\n33  virginica   0.0000000      0.06450608     0.93549392\n34  virginica   0.0000000      0.23111986     0.76888014\n35  virginica   0.0000000      0.00000000     1.00000000\n36  virginica   0.0000000      0.01569160     0.98430840\n37  virginica   0.0000000      0.18857273     0.81142727\n38  virginica   0.0000000      0.33193846     0.66806154\n39  virginica   0.0000000      0.00000000     1.00000000\n40  virginica   0.0000000      0.04881448     0.95118552\n41  virginica   0.0000000      0.00000000     1.00000000\n42  virginica   0.0000000      0.00000000     1.00000000\n43  virginica   0.0000000      0.00000000     1.00000000\n44  virginica   0.0000000      0.12578435     0.87421565\n45 versicolor   0.0000000      0.54547694     0.45452306\n```\n:::\n\n```{.r .cell-code}\ntable(test$Species, fitted(knn))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            \n             setosa versicolor virginica\n  setosa         13          0         0\n  versicolor      0         14         2\n  virginica       0          2        14\n```\n:::\n:::\n\n\n\n## Support Vector Machines (SVMs)\n\nSupport vectors machines have a different approach. They try to divide the predictor space into sectors for each class. To do so, a support-vector machine fits the parameters of a hyperplane (a $n-1$ dimensional subspace in a $n$-dimensional space) in the predictor space by optimizing the distance between the hyperplane and the nearest point from each class. \n\nFitting a support-vector machine:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(e1071)\n\ndata = iris\ndata[,1:4] = apply(data[,1:4], 2, scale)\nindices = sample.int(nrow(data), 0.7*nrow(data))\ntrain = data[indices,]\ntest = data[-indices,]\n\nsm = svm(Species~., data = train, kernel = \"linear\")\npred = predict(sm, newdata = test)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noldpar = par(mfrow = c(1, 2))\nplot(test$Sepal.Length, test$Petal.Length,\n     col =  pred, main = \"predicted\")\nplot(test$Sepal.Length, test$Petal.Length,\n     col =  test$Species, main = \"observed\")\n```\n\n::: {.cell-output-display}\n![](B2-Distance_files/figure-html/chunk_chapter4_36-1.png){width=672}\n:::\n\n```{.r .cell-code}\npar(oldpar)\n\nmean(pred == test$Species) # Accuracy.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9777778\n```\n:::\n:::\n\n\nSupport-vector machines can only work on linearly separable problems. (A problem is called linearly separable if there exists at least one line in the plane with all of the points of one class on one side of the hyperplane and all the points of the others classes on the other side).\n\nIf this is not possible, we however, can use the so called *kernel trick*, which maps the predictor space into a (higher dimensional) space in which the problem is linear separable. After having identified the boundaries in the higher-dimensional space, we can project them back into the original dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 = seq(-3, 3, length.out = 100)\nx2 = seq(-3, 3, length.out = 100)\nX = expand.grid(x1, x2)\ny = apply(X, 1, function(t) exp(-t[1]^2 - t[2]^2))\ny = ifelse(1/(1+exp(-y)) < 0.62, 0, 1)\n\nimage(matrix(y, 100, 100))\nanimation::saveGIF(\n  {\n    for(i in c(\"truth\", \"linear\", \"radial\", \"sigmoid\")){\n      if(i == \"truth\"){\n        image(matrix(y, 100,100),\n        main = \"Ground truth\", axes = FALSE, las = 2)\n      }else{\n        sv = e1071::svm(x = x, y = factor(y), kernel = i)\n        image(matrix(as.numeric(as.character(predict(sv, x))), 100, 100),\n        main = paste0(\"Kernel: \", i), axes = FALSE, las = 2)\n        axis(1, at = seq(0,1, length.out = 10),\n        labels = round(seq(-3, 3, length.out = 10), 1))\n        axis(2, at = seq(0,1, length.out = 10),\n        labels = round(seq(-3, 3, length.out = 10), 1), las = 2)\n      }\n    }\n  },\n  movie.name = \"svm.gif\", autobrowse = FALSE, interval = 2\n)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](./images/svm.gif)\n:::\n:::\n\n\nAs you have seen, this does not work with every kernel. Hence, the problem is to find the actual correct kernel, which is again an optimization procedure and can thus be approximated.\n\n\n## Exercises\n\n\n\n::: {.callout-caution icon=\"false\"}\n#### Question: Sonar data\n\nWe will use the Sonar data set to explore support-vector machines and k-neartest-neighbor classifier.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlbench)\nset.seed(123)\n\ndata(Sonar)\ndata = Sonar\nindices = sample.int(nrow(Sonar), 0.5 * nrow(Sonar))\n```\n:::\n\n\nSplit the Sonar data set from the mlbench library into training- and testset with 50% in each group. Is this a useful split?\nThe response variable is \"class\". So you are trying to classify the class.\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlbench)\nset.seed(123)\n\ndata(Sonar)\ndata = Sonar\n#str(data)\n\n# Do not forget scaling! This may be done implicitly by most functions.\n# Here, it's done explicitly for teaching purposes.\ndata = cbind.data.frame(\n  scale(data[,-length(data)]),\n  \"class\" = data[,length(data)]\n)\n\nn = length(data[,1])\nindicesTrain = sample.int(n, (n+1) %/% 2) # Take (at least) 50 % of the data.\n\ntrain = data[indicesTrain,]\ntest = data[-indicesTrain,]\n\nlabelsTrain = train[,length(train)]\nlabelsTest = test[,length(test)]\n```\n:::\n\n\nUntil you have strong reasons for that, 50/50 is no really good decision. You waste data/power.\nDo not forget scaling!\n\n\n</div>\n\n\n:::\n\n\n\n\n::: {.callout-caution icon=\"false\"}\n#### Question: kNN and SVM\n\nFit a standard k-nearest-neighbor classifier and a support vector machine with a linear kernel (check help), and report what fitted better.\n\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(e1071)\nlibrary(kknn)\n\nknn = kknn(class~., train = train, test = test, scale = FALSE,\n           kernel = \"rectangular\")\npredKNN = predict(knn, newdata = test)\n\nsm = svm(class~., data = train, scale = FALSE, kernel = \"linear\")\npredSVM = predict(sm, newdata = test)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nK-nearest-neighbor, standard (rectangular) kernel:\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n       labelsTest\npredKNN  M  R\n      M 46 29\n      R  8 21\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nCorrectly classified:  67  /  104\n```\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nSupport-vector machine, linear kernel:\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n       labelsTest\npredSVM  M  R\n      M 41 15\n      R 13 35\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nCorrectly classified:  76  /  104\n```\n:::\n:::\n\n\nK-nearest neighbor fitted (slightly) better.\n\n\n</div>\n\n\n:::\n\n::: {.callout-caution icon=\"false\"}\n#### Question: Reproducibility\n\n1.  Calculate accuracies of both algorithms.\n2.  Try the fit again with a different seed for training and test set generation.\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(accKNN = mean(predKNN == labelsTest))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6442308\n```\n:::\n\n```{.r .cell-code}\n(accSVM = mean(predSVM == labelsTest))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7307692\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\ndata = Sonar\ndata = cbind.data.frame(\n  scale(data[,-length(data)]),\n  \"class\" = data[,length(data)]\n)\n\nn = length(data[,1])\nindicesTrain = sample.int(n, (n+1) %/% 2)\n\ntrain = data[indicesTrain,]\ntest = data[-indicesTrain,]\n\nlabelsTrain = train[,length(train)]\nlabelsTest = test[,length(test)]\n\n#####\n\nknn = kknn(class~., train = train, test = test, scale = FALSE,\n           kernel = \"rectangular\")\npredKNN = predict(knn, newdata = test)\n\nsm = svm(class~., data = train, scale = FALSE, kernel = \"linear\")\npredSVM = predict(sm, newdata = test)\n\n(accKNN = mean(predKNN == labelsTest))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7115385\n```\n:::\n\n```{.r .cell-code}\n(accSVM = mean(predSVM == labelsTest))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.75\n```\n:::\n\n```{.r .cell-code}\n#####\n\nknn = kknn(class~., train = train, test = test, scale = FALSE,\n           kernel = \"optimal\")\npredKNN = predict(knn, newdata = test)\n\nsm = svm(class~., data = train, scale = FALSE, kernel = \"radial\")\npredSVM = predict(sm, newdata = test)\n\n(accKNN = mean(predKNN == labelsTest))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8557692\n```\n:::\n\n```{.r .cell-code}\n(accSVM = mean(predSVM == labelsTest))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8365385\n```\n:::\n:::\n\n\n\n</div>\n\n\n:::\n",
    "supporting": [
      "B2-Distance_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}