{
  "hash": "f0a9ea0ad4aae233ae14ee290af4792a",
  "result": {
    "engine": "knitr",
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n\n\n# Recurrent Neural Networks (RNN)\n\n\n\n\n\n\n\n\n\nRecurrent neural networks are used to model sequential data, i.e. a temporal sequence that exhibits temporal dynamic behavior. Here is a good introduction to the topic:\n\n\n\n\n<iframe width=\"560\" height=\"315\" \n  src=\"https://www.youtube.com/embed/SEnXr6v2ifU\"\n  frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media;\n  gyroscope; picture-in-picture\" allowfullscreen>\n  </iframe>\n\n\n\n\n## Case Study: Predicting drought\n\nWe will use a subset of the data explained in [this github repository](https://github.com/Epistoteles/predicting-drought)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::download.file(\"https://www.dropbox.com/s/radyscnl5zcf57b/weather_soil.RDS?raw=1\", destfile = \"weather_soil.RDS\")\ndata = readRDS(\"weather_soil.RDS\")\nX = data$train # Features of the last 180 days\ndim(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 999 180  21\n```\n\n\n:::\n\n```{.r .cell-code}\n# 999 batches of 180 days with 21 features each\nY = data$target\ndim(Y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 999   6\n```\n\n\n:::\n\n```{.r .cell-code}\n# 999 batches of 6 week drought predictions\n\n# let's visualize drought over 24 months:\n# -> We have to take 16 batches (16*6 = 96 weaks ( = 24 months) )\nplot(as.vector(Y[1:16,]), type = \"l\", xlab = \"week\", ylab = \"Drought\")\n```\n\n::: {.cell-output-display}\n![](C4-RecurrentNeuralNetworks_files/figure-html/chunk_chapter5_0_Rnn-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(torch)\n\nholdout = 700:999\nX_train = X[-holdout,,]\nX_test = X[holdout,,]\n\nY_train = Y[-holdout,]\nY_test = Y[holdout,]\n\n\n\nnet = nn_module(\n  initialize = function() {\n    self$lstm = nn_lstm(input_size = 21L, hidden_size = 50L ,batch_first = TRUE)\n    self$linear = nn_linear(50,  6L)\n  }, \n  forward = function(x) {\n    x = self$lstm(x)\n    # two outputs -> [batch, seq_len, hidden] , last hidden state\n    x = x[[1]][,dim(x[[1]])[2], ]\n    return(self$linear(x))\n  }\n)\n\n# training loop\nmodel = net()\n\ntrain_dl = dataloader(tensor_dataset(torch_tensor(X_train), torch_tensor(Y_train)), batch_size = 100L, shuffle = TRUE )\n\nopt = optim_adam(params = model$parameters, lr = 0.01)\nepochs = 100L\noverall_train_loss = c()\nfor(e in 1:epochs) {\n  losses = losses_val = c()\n  model$train() # -> dropout is on\n  coro::loop(\n    for(batch in train_dl) {\n      x = batch[[1]] # Feature matrix/tensor\n      y = batch[[2]] # Response matrix/tensor\n      opt$zero_grad() # reset optimizer\n      pred = model(x)\n      loss = nnf_mse_loss(pred, y)\n      loss$backward()\n      opt$step() # update weights\n      losses = c(losses, loss$item())\n    }\n  )\n  overall_train_loss = c(overall_train_loss, mean(losses))\n  cat(sprintf(\"Loss at epoch: %d train: %3f\\n\", e, mean(losses)))\n\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLoss at epoch: 1 train: 1.994906\nLoss at epoch: 2 train: 0.856170\nLoss at epoch: 3 train: 0.476273\nLoss at epoch: 4 train: 0.380085\nLoss at epoch: 5 train: 0.376748\nLoss at epoch: 6 train: 0.357207\nLoss at epoch: 7 train: 0.341953\nLoss at epoch: 8 train: 0.346024\nLoss at epoch: 9 train: 0.336112\nLoss at epoch: 10 train: 0.333987\nLoss at epoch: 11 train: 0.331322\nLoss at epoch: 12 train: 0.296810\nLoss at epoch: 13 train: 0.296099\nLoss at epoch: 14 train: 0.283915\nLoss at epoch: 15 train: 0.278939\nLoss at epoch: 16 train: 0.271180\nLoss at epoch: 17 train: 0.276021\nLoss at epoch: 18 train: 0.267254\nLoss at epoch: 19 train: 0.255515\nLoss at epoch: 20 train: 0.243821\nLoss at epoch: 21 train: 0.241473\nLoss at epoch: 22 train: 0.245328\nLoss at epoch: 23 train: 0.252983\nLoss at epoch: 24 train: 0.275309\nLoss at epoch: 25 train: 0.261029\nLoss at epoch: 26 train: 0.234615\nLoss at epoch: 27 train: 0.220224\nLoss at epoch: 28 train: 0.203021\nLoss at epoch: 29 train: 0.181731\nLoss at epoch: 30 train: 0.175554\nLoss at epoch: 31 train: 0.175870\nLoss at epoch: 32 train: 0.195022\nLoss at epoch: 33 train: 0.183308\nLoss at epoch: 34 train: 0.168748\nLoss at epoch: 35 train: 0.168387\nLoss at epoch: 36 train: 0.153121\nLoss at epoch: 37 train: 0.149006\nLoss at epoch: 38 train: 0.151347\nLoss at epoch: 39 train: 0.150211\nLoss at epoch: 40 train: 0.135393\nLoss at epoch: 41 train: 0.126832\nLoss at epoch: 42 train: 0.116456\nLoss at epoch: 43 train: 0.113194\nLoss at epoch: 44 train: 0.106261\nLoss at epoch: 45 train: 0.101918\nLoss at epoch: 46 train: 0.097186\nLoss at epoch: 47 train: 0.093761\nLoss at epoch: 48 train: 0.091179\nLoss at epoch: 49 train: 0.087262\nLoss at epoch: 50 train: 0.086706\nLoss at epoch: 51 train: 0.093703\nLoss at epoch: 52 train: 0.092632\nLoss at epoch: 53 train: 0.089517\nLoss at epoch: 54 train: 0.087657\nLoss at epoch: 55 train: 0.082732\nLoss at epoch: 56 train: 0.078252\nLoss at epoch: 57 train: 0.074534\nLoss at epoch: 58 train: 0.076109\nLoss at epoch: 59 train: 0.072607\nLoss at epoch: 60 train: 0.070278\nLoss at epoch: 61 train: 0.069510\nLoss at epoch: 62 train: 0.065573\nLoss at epoch: 63 train: 0.066073\nLoss at epoch: 64 train: 0.062593\nLoss at epoch: 65 train: 0.060189\nLoss at epoch: 66 train: 0.058890\nLoss at epoch: 67 train: 0.057784\nLoss at epoch: 68 train: 0.057428\nLoss at epoch: 69 train: 0.054572\nLoss at epoch: 70 train: 0.056867\nLoss at epoch: 71 train: 0.055438\nLoss at epoch: 72 train: 0.052952\nLoss at epoch: 73 train: 0.052330\nLoss at epoch: 74 train: 0.052945\nLoss at epoch: 75 train: 0.055448\nLoss at epoch: 76 train: 0.052313\nLoss at epoch: 77 train: 0.048622\nLoss at epoch: 78 train: 0.050235\nLoss at epoch: 79 train: 0.047862\nLoss at epoch: 80 train: 0.049148\nLoss at epoch: 81 train: 0.047287\nLoss at epoch: 82 train: 0.053710\nLoss at epoch: 83 train: 0.054321\nLoss at epoch: 84 train: 0.054545\nLoss at epoch: 85 train: 0.054815\nLoss at epoch: 86 train: 0.050959\nLoss at epoch: 87 train: 0.093483\nLoss at epoch: 88 train: 0.098891\nLoss at epoch: 89 train: 0.093983\nLoss at epoch: 90 train: 0.092342\nLoss at epoch: 91 train: 0.096662\nLoss at epoch: 92 train: 0.092818\nLoss at epoch: 93 train: 0.096260\nLoss at epoch: 94 train: 0.080524\nLoss at epoch: 95 train: 0.072129\nLoss at epoch: 96 train: 0.061361\nLoss at epoch: 97 train: 0.053054\nLoss at epoch: 98 train: 0.057596\nLoss at epoch: 99 train: 0.056570\nLoss at epoch: 100 train: 0.054325\n```\n\n\n:::\n\n```{.r .cell-code}\npreds = as.matrix(model(torch_tensor(X_test)))\n\n\n\n\n\nmatplot(cbind(as.vector(preds[1:48,]),  \n              as.vector(Y_test[1:48,])), \n        col = c(\"darkblue\", \"darkred\"),\n        type = \"l\", \n        pch = c(15, 16),\n        xlab = \"week\", ylab = \"Drought\")\nlegend(\"topright\", bty = \"n\", \n       col = c(\"darkblue\", \"darkred\"),\n      pch = c(15, 16), \n      legend = c(\"Prediction\", \"True Values\"))\n```\n\n::: {.cell-output-display}\n![](C4-RecurrentNeuralNetworks_files/figure-html/chunk_chapter5_1_Rnn-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n<!-- The following code snippet shows you many (technical) things you need for building more complex network structures, even with LSTM cells (the following example doesn't have any functionality, it is just an example for how to process two different inputs in different ways within one network): -->\n\n<!-- ::: panel-tabset -->\n<!-- ## Keras -->\n\n<!-- ```{r chunk_chapter5_1, message=FALSE, warning=FALSE} -->\n<!-- library(tensorflow) -->\n<!-- library(keras3) -->\n\n\n<!-- inputDimension1 = 50L -->\n<!-- inputDimension2 = 10L -->\n\n<!-- input1 = layer_input(shape = inputDimension1) -->\n<!-- input2 = layer_input(shape = inputDimension2) -->\n\n<!-- modelInput2 = input2 %>% -->\n<!--   layer_dropout(rate = 0.5) %>% -->\n<!--   layer_dense(units = inputDimension2, activation = \"gelu\") -->\n\n<!-- modelMemory = input1 %>% -->\n<!--   layer_embedding(input_dim = inputDimension1, output_dim = 64L) %>% -->\n<!--   layer_lstm(units = 64L) %>% -->\n<!--   layer_dropout(rate = 0.5) %>% -->\n<!--   layer_dense(units = 2L, activation = \"sigmoid\") -->\n\n<!-- modelDeep = input1 %>% -->\n<!--   layer_dropout(rate = 0.5) %>% -->\n<!--   layer_dense(units = 64L, activation = \"relu\") %>% -->\n<!--   layer_dropout(rate = 0.3) %>% -->\n<!--   layer_dense(units = 64L, activation = \"relu\") %>% -->\n<!--   layer_dense(units = 64L, activation = \"relu\") %>% -->\n<!--   layer_dense(units = 5L, activation = \"sigmoid\") -->\n\n<!-- modelMain = layer_concatenate(c(modelMemory, modelDeep, modelInput2)) %>% -->\n<!--   layer_dropout(rate = 0.25) %>% -->\n<!--   layer_dense(units = 64L, activation = \"relu\") %>% -->\n<!--   layer_dropout(rate = 0.3) %>% -->\n<!--   layer_dense(units = 64L, activation = \"relu\") %>% -->\n<!--   layer_dense(units = 2L, activation = \"sigmoid\") -->\n\n<!-- model = keras_model( -->\n<!--   inputs = c(input1, input2), -->\n<!--   outputs = c(modelMain)  # Use the whole modelMain (resp. its output) as output. -->\n<!-- ) -->\n\n<!-- summary(model) -->\n<!-- # model %>% plot_model() -->\n<!-- ``` -->\n\n<!-- ## Torch -->\n\n<!-- ```{r chunk_chapter5_1_torch, message=FALSE, warning=FALSE} -->\n<!-- library(torch) -->\n\n<!-- model_torch = nn_module( -->\n<!--   initialize = function(type, inputDimension1 = 50L, inputDimension2 = 10L) { -->\n<!--     self$dim1 = inputDimension1 -->\n<!--     self$dim2 = inputDimension2 -->\n<!--     self$modelInput2 = nn_sequential( -->\n<!--       nn_dropout(0.5), -->\n<!--       nn_linear(in_features = self$dim2, out_features = self$dim2), -->\n<!--       nn_selu() -->\n<!--     ) -->\n<!--     self$modelMemory = nn_sequential( -->\n<!--       nn_embedding(self$dim1, 64), -->\n<!--       nn_lstm(64, 64) -->\n<!--     ) -->\n<!--     self$modelMemoryOutput = nn_sequential( -->\n<!--       nn_dropout(0.5), -->\n<!--       nn_linear(64L, 2L), -->\n<!--       nn_sigmoid() -->\n<!--     ) -->\n\n<!--     self$modelDeep = nn_sequential( -->\n<!--       nn_dropout(0.5), -->\n<!--       nn_linear(self$dim1, 64L), -->\n<!--       nn_relu(), -->\n<!--       nn_dropout(0.3), -->\n<!--       nn_linear(64, 64), -->\n<!--       nn_relu(), -->\n<!--       nn_linear(64, 64), -->\n<!--       nn_relu(), -->\n<!--       nn_linear(64, 5), -->\n<!--       nn_sigmoid() -->\n<!--     ) -->\n\n<!--     self$modelMain = nn_sequential( -->\n<!--       nn_linear(7+self$dim2, 64), -->\n<!--       nn_relu(), -->\n<!--       nn_dropout(0.5), -->\n<!--       nn_linear(64, 64), -->\n<!--       nn_relu(), -->\n<!--       nn_dropout(), -->\n<!--       nn_linear(64, 2), -->\n<!--       nn_sigmoid() -->\n<!--     ) -->\n<!--   }, -->\n\n<!--   forward = function(x) { -->\n<!--     input1 = x[[1]] -->\n<!--     input2 = x[[2]] -->\n<!--     out2 = self$modelInput2(input2) -->\n<!--     out1 = self$modelMemoryOutput( self$modelMemory(input1)$view(list(dim(input1)[1], -1)) ) -->\n<!--     out3 = self$modelDeep(input1) -->\n<!--     out = self$modelMain(torch_cat(list(out1, out2, out3), 2)) -->\n<!--     return(out) -->\n<!--   } -->\n\n<!-- ) -->\n\n<!-- (model_torch()) -->\n\n<!-- ``` -->\n<!-- ::: -->\n",
    "supporting": [
      "C4-RecurrentNeuralNetworks_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}