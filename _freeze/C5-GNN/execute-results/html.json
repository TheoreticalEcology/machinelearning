{
  "hash": "d1579c69119a559c2dec9a7a27c113f2",
  "result": {
    "engine": "knitr",
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n\n\n# Graph Neural Networks (GNNs)\n\n\n\n\n\n\n\n\n\nGraph neural networks (GNN) is a young representative of the deep neural network family but is receiving more and more attention in the last years because of their ability to process non-Euclidean data such as graphs.\n\nCurrently there is no R package for GNNs available. However, we can use the 'reticulate' package to use the python packages 'torch' (python version) and 'torch_geometric'.\n\nThe following example was mostly adapted from the 'Node Classification with Graph Neural Networks' example from the [torch_geometric documentation](https://pytorchgeometric.readthedocs.io/en/latest/notes/colabs.html).\n\nThe dataset is also provided by the 'torch_geometric' package and consists of molecules presented as graphs and the task is to predict whether HIV virus replication is inhibited by the molecule or not (classification, binary classification).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\n# Load python packages torch and torch_geometric via the reticulate R package\ntorch = import(\"torch\") \ntorch_geometric = import(\"torch_geometric\")\n# helper functions from the torch_geometric modules\nGCNConv = torch_geometric$nn$GCNConv\nglobal_mean_pool = torch_geometric$nn$global_mean_pool\n# Download the MUTAG TUDataset\ndataset = torch_geometric$datasets$TUDataset(root='data/TUDataset', \n                                             name='MUTAG')\ndataloader = torch_geometric$loader$DataLoader(dataset, \n                                               batch_size=64L,\n                                               shuffle=TRUE)\n# Create the model with a python class\n# There are two classes in the response variable\nGCN = PyClass(\n  \"GCN\", \n   inherit = torch$nn$Module, \n   defs = list(\n       `__init__` = function(self, hidden_channels) {\n         super()$`__init__`()\n         torch$manual_seed(42L)\n         self$conv = GCNConv(dataset$num_node_features, hidden_channels)\n         self$linear = torch$nn$Linear(hidden_channels, dataset$num_classes)\n         NULL\n       },\n       forward = function(self, x, edge_index, batch) {\n         x = self$conv(x, edge_index)\n         x = x$relu()\n         x = global_mean_pool(x, batch)\n         \n         x = torch$nn$functional$dropout(x, p = 0.5, training=self$training)\n         x = self$linear(x)\n         return(x)\n       }\n   ))\n```\n:::\n\n\n\n\nTraining loop:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create model object\nmodel = GCN(hidden_channels = 64L)\n# get optimizer and loss function\noptimizer = torch$optim$Adamax(model$parameters(), lr = 0.01)\nloss_func = torch$nn$CrossEntropyLoss()\n# set model into training mode (because of the dropout layer)\nmodel$train()\n# train model\nfor(e in 1:50) {\n  iterator = reticulate::as_iterator(dataloader)\n  coro::loop(for (b in iterator) { \n     pred = model(b$x, b$edge_index, b$batch)\n     loss = loss_func(pred, b$y)\n     loss$backward()\n     optimizer$step()\n     optimizer$zero_grad()\n  })\n  if(e %% 10 ==0) cat(paste0(\"Epoch: \",e,\" Loss: \", round(loss$item()[1], 4), \"\\n\"))\n}\n## Epoch: 10 Loss: 0.6151\n## Epoch: 20 Loss: 0.6163\n## Epoch: 30 Loss: 0.5745\n## Epoch: 40 Loss: 0.5362\n## Epoch: 50 Loss: 0.5829\n```\n:::\n\n\n\n\nMake predictions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreds = list()\ntest = torch_geometric$loader$DataLoader(dataset, batch_size=64L,shuffle=FALSE)\niterator = reticulate::as_iterator(test)\nmodel$eval()\ncounter = 1\ncoro::loop(for (b in iterator) {\n  preds[[counter]] = model(b$x, b$edge_index, b$batch)\n  counter <<- counter + 1\n  })\nhead(torch$concat(preds)$sigmoid()$data$cpu()$numpy(), n = 3)\n##          [,1]      [,2]\n## [1,] 0.3076028 0.6427078\n## [2,] 0.4121239 0.5515330\n## [3,] 0.4119514 0.5516798\n```\n:::\n",
    "supporting": [
      "C5-GNN_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}