{
  "hash": "ea11de8476f926bdc927ded55eefe2f6",
  "result": {
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n# Bias-variance trade-off\n\n## Understanding the bias-variance trade-off\n\n::: {.webex-check .webex-box}\n![](images/biasVarianceTradeoff.png)\n\n\nWhich of the following statements about the bias-variance trade-off is correct? (see figure above) <div class='webex-radiogroup' id='radio_GXEHSKYAUV'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_GXEHSKYAUV\" value=\"answer\"></input> <span>The goal of considering the bias-variance trade-off is to realize that increasing complexity typically leads to more flexibility (allowing you to reduce bias) but at the cost of uncertainty (variance) in the estimated parameters.</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_GXEHSKYAUV\" value=\"\"></input> <span>The goal of considering the bias-variance trade-off is to get the bias of the model as small as possible.</span></label></div>\n\n:::\n\n## Optimizing the bias-variance trade-off\n\nOptimizing the bias-variance trade-off means adjusting the complexity of the model which can be achieved by:\n\n-   Feature selection (more features increases the flexibility of the model)\n\n-   Regularization\n\n### Feature selection\n\nAdding features increases the flexibility of the model and the goodness of fit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlbench)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\ndata(BostonHousing)\ndata = BostonHousing\n\nsummary(lm(medv~rm, data = data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = medv ~ rm, data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-23.346  -2.547   0.090   2.986  39.433 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -34.671      2.650  -13.08   <2e-16 ***\nrm             9.102      0.419   21.72   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.616 on 504 degrees of freedom\nMultiple R-squared:  0.4835,\tAdjusted R-squared:  0.4825 \nF-statistic: 471.8 on 1 and 504 DF,  p-value: < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\nsummary(lm(medv~rm+dis, data = data))$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4955246\n```\n:::\n\n```{.r .cell-code}\nsummary(lm(medv~., data = data))$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7406427\n```\n:::\n\n```{.r .cell-code}\n# Main effects + all potential interactions:\nsummary(lm(medv~.^2, data = data))$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9211876\n```\n:::\n:::\n\n\nThe model with all features and their potential interactions has the highest $R^2$, but it also has the highest uncertainty because there are on average only 5 observations for each parameter (92 parameters and 506 observations). So how do we decide which level of complexity is appropriate for our task? For the data we use to train the model, $R^2$ will always get better with higher model complexity, so it is a poor decision criterion. We will show this in the @sec-cv section. In short, the idea is that we need to split the data so that we have an evaluation (test) dataset that wasn't used to train the model, which we can then use in turn to see if our model generalizes well to new data.\n\n### Regularization\n\nRegularization means adding information or structure to a system in order to solve an ill-posed optimization problem or to prevent overfitting. There are many ways of regularizing a machine learning model. The most important distinction is between *shrinkage estimators* and estimators based on *model averaging*.\n\n**Shrikage estimators** are based on the idea of adding a penalty to the loss function that penalizes deviations of the model parameters from a particular value (typically 0). In this way, estimates are *\"shrunk\"* to the specified default value. In practice, the most important penalties are the least absolute shrinkage and selection operator; also *Lasso* or *LASSO*, where the penalty is proportional to the sum of absolute deviations ($L1$ penalty), and the *Tikhonov regularization* aka *Ridge regression*, where the penalty is proportional to the sum of squared distances from the reference ($L2$ penalty). Thus, the loss function that we optimize is given by\n\n$$\nloss = fit - \\lambda \\cdot d\n$$\n\nwhere fit refers to the standard loss function, $\\lambda$ is the strength of the regularization, and $d$ is the chosen metric, e.g. $L1$ or$L2$:\n\n$$\nloss_{L1} = fit - \\lambda \\cdot \\Vert weights \\Vert_1\n$$\n\n$$\nloss_{L2} = fit - \\lambda \\cdot \\Vert weights \\Vert_2\n$$\n\n$\\lambda$ and possibly d are typically optimized under cross-validation. $L1$ and $L2$ can be also combined what is then called *elastic net* (see @zou2005).\n\n**Model averaging** refers to an entire set of techniques, including *boosting*, *bagging* and other averaging techniques. The general principle is that predictions are made by combining (= averaging) several models. This is based on on the insight that it is often more efficient having many simpler models and average them, than one \"super model\". The reasons are complicated, and explained in more detail in @dormann2018.\n\nA particular important application of averaging is *boosting*, where the idea is that many weak learners are combined to a model average, resulting in a strong learner. Another related method is *bootstrap aggregating*, also called *bagging*. Idea here is to *boostrap* (use random sampling with replacement ) the data, and average the bootstrapped predictions.\n\nTo see how these techniques work in practice, let's first focus on LASSO and Ridge regularization for weights in neural networks. We can imagine that the LASSO and Ridge act similar to a rubber band on the weights that pulls them to zero if the data does not strongly push them away from zero. This leads to important weights, which are supported by the data, being estimated as different from zero, whereas unimportant model structures are reduced (shrunken) to zero.\n\nLASSO $\\left(penalty \\propto \\sum_{}^{} \\mathrm{abs}(weights) \\right)$ and Ridge $\\left(penalty \\propto \\sum_{}^{} weights^{2} \\right)$ have slightly different properties. They are best understood if we express those as the effective prior preference they create on the parameters:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](A3-BiasVarianceTradeOff_files/figure-html/chunk_chapter4_10-1.png){width=672}\n:::\n:::\n\n\nAs you can see, the LASSO creates a very strong preference towards exactly zero, but falls off less strongly towards the tails. This means that parameters tend to be estimated either to exactly zero, or, if not, they are more free than the Ridge. For this reason, LASSO is often more interpreted as a model selection method.\n\nThe Ridge, on the other hand, has a certain area around zero where it is relatively indifferent about deviations from zero, thus rarely leading to exactly zero values. However, it will create a stronger shrinkage for values that deviate significantly from zero.\n\n#### Ridge - Example\n\nWe can use the `glmnet` package for Ridge, LASSO, and elastic-net regressions.\n\nWe want to predict the house prices of Boston (see help of the dataset):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mlbench)\nlibrary(dplyr)\nlibrary(glmnet)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Matrix\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoaded glmnet 4.1-7\n```\n:::\n\n```{.r .cell-code}\ndata(BostonHousing)\ndata = BostonHousing\nY = data$medv\nX = data %>% select(-medv, -chas) %>% scale()\n\nhist(cor(X))\n```\n\n::: {.cell-output-display}\n![](A3-BiasVarianceTradeOff_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 = glmnet(y = Y, x = X, alpha = 0)\n```\n:::\n\n\nThe `glmnet` function automatically tries different values for lambda:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(coef(m1, s = 0.001), coef(m1, s = 100.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13 x 2 sparse Matrix of class \"dgCMatrix\"\n                     s1          s1\n(Intercept) 22.53280632 22.53280632\ncrim        -0.79174957 -0.21113427\nzn           0.76313031  0.18846808\nindus       -0.17037817 -0.25120998\nnox         -1.32794787 -0.21314250\nrm           2.85780876  0.46463202\nage         -0.05389395 -0.18279762\ndis         -2.38716188  0.07906631\nrad          1.42772476 -0.17967948\ntax         -1.09026758 -0.24233282\nptratio     -1.93105019 -0.31587466\nb            0.86718037  0.18764060\nlstat       -3.43236617 -0.46055837\n```\n:::\n:::\n\n\n#### LASSO - Example\n\nBy changing $alpha$ to 1.0 we use a LASSO instead of a Ridge regression:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2 = glmnet(y = Y, x = X, alpha = 1.0)\ncbind(coef(m2, s = 0.001), coef(m2, s = 0.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13 x 2 sparse Matrix of class \"dgCMatrix\"\n                     s1           s1\n(Intercept) 22.53280632 22.532806324\ncrim        -0.95543108 -0.135047323\nzn           1.06718108  .          \nindus        0.21519500  .          \nnox         -1.95945910 -0.000537715\nrm           2.71666891  2.998520195\nage          0.05184895  .          \ndis         -3.10566908 -0.244045205\nrad          2.73963771  .          \ntax         -2.20279273  .          \nptratio     -2.13052857 -1.644234575\nb            0.88420283  0.561686909\nlstat       -3.80177809 -3.682148016\n```\n:::\n:::\n\n\n#### Elastic-net - Example\n\nBy setting $alpha$ to a value between 0 and 1.0, we use a combination of LASSO and Rdige:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 = glmnet(y = Y, x = X, alpha = 0.5)\ncbind(coef(m3, s = 0.001), coef(m3, s = 0.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13 x 2 sparse Matrix of class \"dgCMatrix\"\n                     s1         s1\n(Intercept) 22.53280632 22.5328063\ncrim        -0.95716118 -0.3488473\nzn           1.06836343  0.1995842\nindus        0.21825187  .        \nnox         -1.96211736 -0.7613698\nrm           2.71859592  3.0137090\nage          0.05299551  .        \ndis         -3.10330132 -1.3011740\nrad          2.73321635  .        \ntax         -2.19638611  .        \nptratio     -2.13041090 -1.8051547\nb            0.88458269  0.6897165\nlstat       -3.79836182 -3.6136853\n```\n:::\n:::\n\n\n### Hyperparameters\n\nGenerally, parameters such as $\\lambda$ and $\\alpha$ that, for example, control the complexity or other parameters that control their learning or the optimization are called hyperparameters. Comming back to our glmnet example:\n\nWe can plot the effect of $\\lambda$ on the effect estimates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(m1)\n```\n\n::: {.cell-output-display}\n![](A3-BiasVarianceTradeOff_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nSo which lambda should we choose now? If we calculate the model fit for different lambdas (e.g. using the RMSE):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambdas = seq(0.001, 1.5, length.out = 100)\nRMSEs = \n  sapply(lambdas, function(l) {\n    prediction = predict(m1, newx = X, s = l)\n    RMSE = Metrics::rmse(Y, prediction)\n    return(RMSE)\n    })\nplot(lambdas, RMSEs)\n```\n\n::: {.cell-output-display}\n![](A3-BiasVarianceTradeOff_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nWe see that the lowest lambda achieved the highest RMSE - which is not surprising because the unconstrained model, the most complex model, has the highest fit, so no bias but probably high variance (with respect to the bias-variance tradeoff).\n\n#### Split data into training and testing\n\nWe want a model that generalizes well to new data, which we need to \"simulate\" here by splitting of a holdout before the training and using the holdout then for testing our model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nlibrary(mlbench)\nlibrary(dplyr)\ndata(BostonHousing)\ndata = BostonHousing\nY = data$medv\nX = data %>% select(-medv, -chas) %>% scale()\n\n# Split data\nindices = sample.int(nrow(X), 0.2*nrow(X))\ntrain_X = X[indices,]\ntest_X = X[-indices,]\ntrain_Y = Y[indices]\ntest_Y = Y[-indices]\n\n# Train model on train data\nm1 = glmnet(y = train_Y, x = train_X, alpha = 0.5)\n\n# Test model on test data\npred = predict(m1, newx = test_X, s = 0.01)\n\n# Calculate performance on test data\nMetrics::rmse(test_Y, pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.063774\n```\n:::\n:::\n\n\nLet's do it again for different values of lambdas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambdas = seq(0.0000001, 0.5, length.out = 100)\nRMSEs = \n  sapply(lambdas, function(l) {\n    prediction = predict(m1, newx = test_X, s = l)\n    return(Metrics::rmse(test_Y, prediction))\n    })\nplot(lambdas, RMSEs, xlab = \"Lambda\", ylab = \"RMSE\", type = \"l\", las = 2)\nabline(v = lambdas[which.min(RMSEs)], col = \"red\", lwd = 1.5)\n```\n\n::: {.cell-output-display}\n![](A3-BiasVarianceTradeOff_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nHyperparameter tuning describes the process of finding the optimal set of hyperparameters for a certain task. They are usually data specific, so they have to tuned for each dataset.\n\nIf we do only one split it could happen that we only find a set of hyperparameters that are best suited for this specific split and thus we usally do several splits so that each observation is once an observation in the test dataset, cross-validation\n\n### Cross-validation {#sec-cv}\n\nThe `cv.glmnet` function does per default a 5xCV (so 5 splits) and in each split different values for $\\lambda$ are tested\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 = glmnet::cv.glmnet(x = X, y = Y, alpha = 0.5, nfolds = 5)\nm1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:  glmnet::cv.glmnet(x = X, y = Y, nfolds = 5, alpha = 0.5) \n\nMeasure: Mean-Squared Error \n\n    Lambda Index Measure    SE Nonzero\nmin 0.0105    78   23.80 3.247      12\n1se 0.6905    33   26.88 4.014       8\n```\n:::\n\n```{.r .cell-code}\nplot(m1)\n```\n\n::: {.cell-output-display}\n![](A3-BiasVarianceTradeOff_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\nm1$lambda.min\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.01049538\n```\n:::\n:::\n\n\nSo low values of $\\lambda$ seem to achieve the lowest error, thus the higehst predictive performance.\n\nThis is called hyperparameter tuning.\n",
    "supporting": [
      "A3-BiasVarianceTradeOff_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}