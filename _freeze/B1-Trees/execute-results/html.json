{
  "hash": "d84bbdd6a0e3934997407300ff0dcd11",
  "result": {
    "engine": "knitr",
    "markdown": "---\noutput: html_document\neditor_options:\n  chunk_output_type: console\n---\n\n\n\n\n# Tree-based Algorithms\n\n## Classification and Regression Trees\n\nTree-based algorithms use a series of if-then rules to generate predictions from one or more decision trees. In this lecture, we will explore regression and classification trees by the example of the airquality data set. There is one important hyperparameter for regression trees: \"minsplit\".\n\n-   It controls the depth of tree (see the help of rpart for a description).\n-   It controls the complexity of the tree and can thus also be seen as a regularization parameter.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rpart)\nlibrary(rpart.plot)\n\ndata = airquality[complete.cases(airquality),]\n```\n:::\n\n\n\n\nFit and visualize one(!) regression tree:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrt = rpart(Ozone~., data = data, control = rpart.control(minsplit = 10))\nrpart.plot(rt)\n```\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\nVisualize the predictions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred = predict(rt, data)\nplot(data$Temp, data$Ozone)\nlines(data$Temp[order(data$Temp)], pred[order(data$Temp)], col = \"red\")\n```\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_24-1.png){width=672}\n:::\n:::\n\n\n\n\nThe angular form of the prediction line is typical for regression trees and is a weakness of it.\n\n## Random Forest\n\nTo overcome this weakness, a random forest uses an ensemble of regression/classification trees. In principle, a random forest is nothing more than a normal regression/classification tree, but it uses the idea of \"wisdom of the crowd\": by asking many people (regression/classification trees), you can make a more informed decision (prediction/classification). For example, if you wanted to buy a new phone, you wouldn't go directly to the store, but you would search the Internet and ask your friends and family.\n\nThere are two randomization steps with the random forest that are responsible for their success:\n\n-   **Bootstrap samples** for each tree (we will sample observations with replacement from the data set. For the phone this is like not everyone has experience about each phone).\n-   At each split, we will **sample a subset of predictors** that is then considered as potential splitting criterion (for the phone this is like that not everyone has the same decision criteria). Annotation: While building a decision tree (random forests consist of many decision trees), one splits the data at some point according to their features. For example if you have females and males, big and small people in a crowd, you con split this crowd by gender and then by size or by size and then by gender to build a decision tree.\n\nApplying the random forest follows the same principle as for the methods before: We visualize the data (we have already done this so often for the airquality data set, thus we skip it here), fit the algorithm and then plot the outcomes.\n\nFit a random forest and visualize the predictions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(randomForest)\nset.seed(123)\n\ndata = airquality[complete.cases(airquality),]\n\nrf = randomForest(Ozone~., data = data)\npred = predict(rf, data)\nplot(Ozone~Temp, data = data)\nlines(data$Temp[order(data$Temp)], pred[order(data$Temp)], col = \"red\")\n```\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_25-1.png){width=672}\n:::\n:::\n\n\n\n\nOne advantage of random forest is that we get an importance of the variables. For each split in each tree, the improvement in the split criterion is the measure of importance attributed to the split variable, and is accumulated over all trees in the forest separately for each variable. Thus, the variable importance tells us how important a variable is averaged across all trees.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf$importance\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        IncNodePurity\nSolar.R      17969.59\nWind         31978.36\nTemp         34176.71\nMonth        10753.73\nDay          15436.47\n```\n\n\n:::\n:::\n\n\n\n\nThere are several important hyperparameters in a random forest that we can tune to get better results:\n\n| Hyperparameter | Explanation |\n|-----------------|-------------------------------------------------------|\n| mtry | Subset of features randomly selected in each node (from which the algorithm can select the feature that will be used to split the data). |\n| minimum node size | Minimal number of observations allowed in a node (before the branching is canceled) |\n| max depth | Maximum number of tree depth |\n\n## Boosted Regression Trees\n\nA boosted regression tree (BRT) starts with a simple regression tree (weak learner) and then sequentially fits additional trees to improve the results. There are two different strategies to do this:\n\n-   *AdaBoost*: Wrong classified observations (by the previous tree) will get a higher weight and therefore the next trees will focus on difficult/missclassified observations.\n-   *Gradient boosting* (state of the art): Each sequential model will be fit on the residual errors of the previous model (strongly simplified, the actual algorithm is complex).\n\nWe can fit a boosted regression tree using xgboost, but before we have to transform the data into a `xgb.Dmatrix` (which is a xgboost specific data type, the package sadly doesn't support R matrices or data.frames).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xgboost)\nset.seed(123)\n\ndata = airquality[complete.cases(airquality),]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_xg = xgb.DMatrix(data = as.matrix(scale(data[,-1])), label = data$Ozone)\nbrt = xgboost(data_xg, nrounds = 16L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]\ttrain-rmse:39.724624 \n[2]\ttrain-rmse:30.225761 \n[3]\ttrain-rmse:23.134840 \n[4]\ttrain-rmse:17.899179 \n[5]\ttrain-rmse:14.097785 \n[6]\ttrain-rmse:11.375457 \n[7]\ttrain-rmse:9.391276 \n[8]\ttrain-rmse:7.889690 \n[9]\ttrain-rmse:6.646586 \n[10]\ttrain-rmse:5.804859 \n[11]\ttrain-rmse:5.128437 \n[12]\ttrain-rmse:4.456416 \n[13]\ttrain-rmse:4.069464 \n[14]\ttrain-rmse:3.674615 \n[15]\ttrain-rmse:3.424578 \n[16]\ttrain-rmse:3.191301 \n```\n\n\n:::\n:::\n\n\n\n\nThe parameter \"nrounds\" controls how many sequential trees we fit, in our example this was 16. When we predict on new data, we can limit the number of trees used to prevent overfitting (remember: each new tree tries to improve the predictions of the previous trees).\n\nLet us visualize the predictions for different numbers of trees:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noldpar = par(mfrow = c(2, 2))\nfor(i in 1:4){\n  pred = predict(brt, newdata = data_xg, ntreelimit = i)\n  plot(data$Temp, data$Ozone, main = i)\n  lines(data$Temp[order(data$Temp)], pred[order(data$Temp)], col = \"red\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[09:03:24] WARNING: src/c_api/c_api.cc:935: `ntree_limit` is deprecated, use `iteration_range` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[09:03:24] WARNING: src/c_api/c_api.cc:935: `ntree_limit` is deprecated, use `iteration_range` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[09:03:24] WARNING: src/c_api/c_api.cc:935: `ntree_limit` is deprecated, use `iteration_range` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[09:03:24] WARNING: src/c_api/c_api.cc:935: `ntree_limit` is deprecated, use `iteration_range` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_29__BRT2-1.png){width=672}\n:::\n\n```{.r .cell-code}\npar(oldpar)\n```\n:::\n\n\n\n\nThere are also other ways to control for complexity of the boosted regression tree algorithm:\n\n-   max_depth: Maximum depth of each tree.\n-   shrinkage (each tree will get a weight and the weight will decrease with the number of trees).\n\nWhen having specified the final model, we can obtain the importance of the variables like for random forests:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxgboost::xgb.importance(model = brt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Feature        Gain     Cover  Frequency\n    <char>       <num>     <num>      <num>\n1:    Temp 0.570072012 0.2958229 0.24836601\n2:    Wind 0.348230653 0.3419576 0.24183007\n3: Solar.R 0.058795502 0.1571072 0.30718954\n4:     Day 0.019529985 0.1779925 0.16993464\n5:   Month 0.003371847 0.0271197 0.03267974\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(mean((data$Ozone - pred)^2)) # RMSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17.89918\n```\n\n\n:::\n\n```{.r .cell-code}\ndata_xg = xgb.DMatrix(data = as.matrix(scale(data[,-1])), label = data$Ozone)\n```\n:::\n\n\n\n\nOne important strength of xgboost is that we can directly do a cross-validation (which is independent of the boosted regression tree itself!) and specify its properties with the parameter \"n-fold\":\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nbrt = xgboost(data_xg, nrounds = 5L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]\ttrain-rmse:39.724624 \n[2]\ttrain-rmse:30.225761 \n[3]\ttrain-rmse:23.134840 \n[4]\ttrain-rmse:17.899179 \n[5]\ttrain-rmse:14.097785 \n```\n\n\n:::\n\n```{.r .cell-code}\nbrt_cv = xgboost::xgb.cv(data = data_xg, nfold = 3L,\n                         nrounds = 3L, nthreads = 4L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]\ttrain-rmse:39.895106+2.127355\ttest-rmse:40.685477+5.745327 \n[2]\ttrain-rmse:30.367660+1.728788\ttest-rmse:32.255812+5.572963 \n[3]\ttrain-rmse:23.446237+1.366757\ttest-rmse:27.282435+5.746244 \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(brt_cv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n##### xgb.cv 3-folds\n  iter train_rmse_mean train_rmse_std test_rmse_mean test_rmse_std\n <num>           <num>          <num>          <num>         <num>\n     1        39.89511       2.127355       40.68548      5.745327\n     2        30.36766       1.728788       32.25581      5.572963\n     3        23.44624       1.366757       27.28244      5.746244\n```\n\n\n:::\n:::\n\n\n\n\nAnnotation: The original data set is randomly partitioned into $n$ equal sized subsamples. Each time, the model is trained on $n - 1$ subsets (training set) and tested on the left out set (test set) to judge the performance.\n\nIf we do three-folded cross-validation, we actually fit three different boosted regression tree models (xgboost models) on $\\approx 67\\%$ of the data points. Afterwards, we judge the performance on the respective holdout. This now tells us how well the model performed.\n\nImportant hyperparameters:\n\n| Hyperparameter | Explanation |\n|------------------|------------------------------------------------------|\n| eta | learning rate (weighting of the sequential trees) |\n| max depth | maximal depth in the trees (small = low complexity, large = high complexity) |\n| subsample | subsample ratio of the data (bootstrap ratio) |\n| lambda | regularization strength of the individual trees |\n| max tree | maximal number of trees in the ensemble |\n\n## Exercise - Trees\n\n::: callout-warning\n#### Question: Understanding complexity in Regression Trees\n\nThe goal of this exercise is to understand how the hyperparameter mincut (minsplit) affects the complexity of regression trees. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tree)\nset.seed(123)\n\ndata = airquality\nrt = tree(Ozone~., data = data,\n          control = tree.control(mincut = 1L, nobs = nrow(data)))\n\nplot(rt)\ntext(rt)\npred = predict(rt, data)\nplot(data$Temp, data$Ozone)\nlines(data$Temp[order(data$Temp)], pred[order(data$Temp)], col = \"red\")\nsqrt(mean((data$Ozone - pred)^2)) # RMSE\n```\n:::\n\n\n\n\nTasks:\n\n- The code snippet above returns NA for the RMSE, what is wrong in the snippet?\n- Read the `tree.control` documentation, what does the mincut parameter do?\n- Try different mincut values and check how the predictions (and the RMSE) change. What was wrong in the snippet above?\n\n:::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tree)\nset.seed(123)\n\ndata = airquality[complete.cases(airquality),]\n\ndoTask = function(mincut){\n  rt = tree(Ozone~., data = data,\n            control = tree.control(mincut = mincut, nobs = nrow(data)))\n\n  pred = predict(rt, data)\n  plot(data$Temp, data$Ozone,\n       main = paste0(\n         \"mincut: \", mincut,\n         \"\\nRMSE: \", round(sqrt(mean((data$Ozone - pred)^2)), 2)\n      )\n  )\n  lines(data$Temp[order(data$Temp)], pred[order(data$Temp)], col = \"red\")\n}\n\nfor(i in c(1, 2, 3, 5, 10, 15, 25, 50, 54, 55, 56, 57, 75, 100)){ doTask(i) }\n```\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-6.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-7.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-8.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-9.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-10.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-11.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-12.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-13.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_22-14.png){width=672}\n:::\n:::\n\n\n\n\nApproximately at mincut = 15, prediction is the best (mind overfitting). After mincut = 56, the prediction has no information at all and the RMSE stays constant.\n\nMind the complete cases of the airquality data set, that was the error. \n\n</div>\n\n\n::: callout-warning\n#### Question: Understanding complexity in Random forest\n\nThe goal of this exercise is to understand how the hyperparameter nodesize affects the complexity of random forest. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(randomForest)\nset.seed(123)\n\ndata = airquality[complete.cases(airquality),]\n\nrf = randomForest(Ozone~., data = data)\n\npred = predict(rf, data)\nimportance(rf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        IncNodePurity\nSolar.R      17969.59\nWind         31978.36\nTemp         34176.71\nMonth        10753.73\nDay          15436.47\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"RMSE: \", sqrt(mean((data$Ozone - pred)^2)), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRMSE:  9.507848 \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(data$Temp, data$Ozone)\nlines(data$Temp[order(data$Temp)], pred[order(data$Temp)], col = \"red\")\n```\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_23-1.png){width=672}\n:::\n:::\n\n\n\n\nTasks:\n\n- Check the documentation of the `randomForest` function and read the description of the nodesize parameter\n- Try different nodesize values and describe how the predictions change\n\n:::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(randomForest)\nset.seed(123)\n\ndata = airquality[complete.cases(airquality),]\n\n\nfor(nodesize in c(1, 15, 50, 100)){\n  for(mtry in c(1, 3, 5)){\n    rf = randomForest(Ozone~., data = data, nodesize = nodesize)\n    \n    pred = predict(rf, data)\n    \n    plot(data$Temp, data$Ozone, main = paste0(\n        \"    nodesize: \", nodesize,\n        \"\\nRMSE: \", round(sqrt(mean((data$Ozone - pred)^2)), 2)\n      )\n    )\n    lines(data$Temp[order(data$Temp)], pred[order(data$Temp)], col = \"red\")\n  }\n}\n```\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-6.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-7.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-8.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-9.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-10.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-11.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/chunk_chapter4_task_24-12.png){width=672}\n:::\n:::\n\n\n\n\nNodesize affects the complexity. In other words: The bigger the nodesize, the smaller the trees and the more bias/less variance.\n\n\n</div>\n\n\n::: callout-warning\n#### Question: Understanding complexity in Boosted regression trees\n\nThe goal of this exercise is to understand how complexity in BRT affects predictions. For that, we will simulate data with two predictors `x1` and `x2` and the `y` response variable will be an interaction of the two predictors:\n\n$$y = e^{-x_1^2 - x_2^2} $$\nWe can visualize the simulated data as an image (x1 and x2 on the x and y axis, and the y values as colors)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xgboost)\nlibrary(animation)\nset.seed(123)\n\nx1 = seq(-3, 3, length.out = 100)\nx2 = seq(-3, 3, length.out = 100)\nx = expand.grid(x1, x2)\ny = apply(x, 1, function(t) exp(-t[1]^2 - t[2]^2))\n\n\nimage(matrix(y, 100, 100), main = \"Original image\", axes = FALSE, las = 2)\naxis(1, at = seq(0, 1, length.out = 10),\n     labels = round(seq(-3, 3, length.out = 10), 1))\naxis(2, at = seq(0, 1, length.out = 10),\n     labels = round(seq(-3, 3, length.out = 10), 1), las = 2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = xgboost::xgboost(xgb.DMatrix(data = as.matrix(x), label = y),\n                         nrounds = 500L, verbose = 0L)\npred = predict(model, newdata = xgb.DMatrix(data = as.matrix(x)),\n               ntreelimit = 10L)\n\nsaveGIF(\n  {\n    for(i in c(1, 2, 4, 8, 12, 20, 40, 80, 200)){\n      pred = predict(model, newdata = xgb.DMatrix(data = as.matrix(x)),\n                     ntreelimit = i)\n      image(matrix(pred, 100, 100), main = paste0(\"Trees: \", i),\n            axes = FALSE, las = 2)\n      axis(1, at = seq(0, 1, length.out = 10),\n           labels = round(seq(-3, 3, length.out = 10), 1))\n      axis(2, at = seq(0, 1, length.out = 10),\n           labels = round(seq(-3, 3, length.out = 10), 1), las = 2)\n    }\n  },\n  movie.name = \"boosting.gif\", autobrowse = FALSE\n)\n```\n:::\n\n\n\n\n\n![](./images/boosting.gif){width=\"370\"}\n\nTasks:\n\n- Run the code above and try different **max_depth** values and describe what you see!\n\nTip: have a look at the boosting.gif.\n:::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xgboost)\nlibrary(animation)\nset.seed(123)\n\nx1 = seq(-3, 3, length.out = 100)\nx2 = seq(-3, 3, length.out = 100)\nx = expand.grid(x1, x2)\ny = apply(x, 1, function(t) exp(-t[1]^2 - t[2]^2))\n\nimage(matrix(y, 100, 100), main = \"Original image\", axes = FALSE, las = 2)\naxis(1, at = seq(0, 1, length.out = 10),\n     labels = round(seq(-3, 3, length.out = 10), 1))\naxis(2, at = seq(0, 1, length.out = 10),\n     labels = round(seq(-3, 3, length.out = 10), 1), las = 2)\n\nfor(max_depth in c(3, 6, 10, 20)){\n  model = xgboost::xgboost(xgb.DMatrix(data = as.matrix(x), label = y),\n                           max_depth = max_depth,\n                           nrounds = 500, verbose = 0L)\n\n  saveGIF(\n    {\n      for(i in c(1, 2, 4, 8, 12, 20, 40, 80, 200)){\n        pred = predict(model, newdata = xgb.DMatrix(data = as.matrix(x)),\n                       ntreelimit = i)\n        image(matrix(pred, 100, 100),\n              main = paste0(\"eta: \", eta,\n                            \"    max_depth: \", max_depth,\n                            \"    Trees: \", i),\n              axes = FALSE, las = 2)\n        axis(1, at = seq(0, 1, length.out = 10),\n             labels = round(seq(-3, 3, length.out = 10), 1))\n        axis(2, at = seq(0, 1, length.out = 10),\n             labels = round(seq(-3, 3, length.out = 10), 1), las = 2)\n      }\n    },\n    movie.name = paste0(\"boosting_\", max_depth, \"_\", eta, \".gif\"),\n    autobrowse = FALSE\n  )\n}\n```\n:::\n\n\n\n\nWe see that for high values of max_depth, the predictions \"smooth out\" faster. On the other hand, with a low max_depth (low complexity of the individual trees), more trees are required in the ensemble to achieve a smooth prediction surface.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?xgboost::xgboost\n```\n:::\n\n\n\n\nJust some examples:\n\n-   ![](./images/boosting_3_0.1.gif){width=\"370\"}\n-   ![](./images/boosting_6_0.7.gif){width=\"370\"}\n-   ![](./images/boosting_20_0.9.gif){width=\"370\"}\n\n\n</div>\n\n\n\n:::: callout-warning\n#### Question: Hyperparameter tuning of boosted regression trees\n\nImportant hyperparameters:\n\n| Hyperparameter | Explanation |\n|------------------|------------------------------------------------------|\n| eta | learning rate (weighting of the sequential trees) |\n| max depth | maximal depth in the trees (small = low complexity, large = high complexity) |\n| subsample | subsample ratio of the data (bootstrap ratio) |\n| lambda | regularization strength of the individual trees |\n| max tree | maximal number of trees in the ensemble |\n\nThe goal of this exercise is to tune a BRT on the titanic_ml dataset and beat yesterday's RF predictions.\n\nPrepare the data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:xgboost':\n\n    slice\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:randomForest':\n\n    combine\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(missRanger)\ndata(titanic_ml)\ndata = titanic_ml\ndata = \n  data %>% select(survived, sex, age, fare, pclass)\ndata[,-1] = missRanger(data[,-1], verbose = 0)\n\ndata_sub =\n  data %>%\n    mutate(age = scales::rescale(age, c(0, 1)),\n           fare = scales::rescale(fare, c(0, 1))) %>%\n    mutate(sex = as.integer(sex) - 1L,\n           pclass = as.integer(pclass - 1L))\ndata_new = data_sub[is.na(data_sub$survived),] # for which we want to make predictions at the end\ndata_obs = data_sub[!is.na(data_sub$survived),] # data with known response\n```\n:::\n\n\n\n\nTasks:\n\n- Tune eta and max depth!\n\n::: {.callout-tip collapse=\"true\" appearance=\"minimal\"}\n## Code template\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xgboost)\nset.seed(42)\ndata_obs = data_sub[!is.na(data_sub$survived),] \ncv = 3\n\nouter_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n\n# sample minnodesize values (must be integers)\nhyper_depth = ...\nhyper_eta = ...\n\ntuning_results =\n    sapply(1:length(hyper_minnodesize), function(k) {\n        auc_inner = NULL\n        for(j in 1:cv) {\n          inner_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n          train_inner = data_obs[inner_split != j, ]\n          test_inner = data_obs[inner_split == j, ]\n          \n          data_xg = xgb.DMatrix(data = as.matrix(train_inner[,-1]), label = train_inner$survived)\n          \n          model = xgboost(data_xg, nrounds = 16L, eta = hyper_eta[k], max_depth = hyper_depth[k], objective = \"reg:logistic\")\n          predictions = predict(model, newdata = as.matrix(test_inner)[,-1])\n          \n          auc_inner[j]= Metrics::auc(test_inner$survived, predictions)\n        }\n      return(mean(auc_inner))\n    })\n\nresults = data.frame(depth = hyper_depth, eta = hyper_eta, AUC = tuning_results)\n\nprint(results)\n```\n:::\n\n\n\n:::\n::::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xgboost)\nset.seed(42)\ndata_obs = data_sub[!is.na(data_sub$survived),] \ncv = 3\n\nouter_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n\n# sample minnodesize values (must be integers)\nhyper_depth = sample(200, 20)\nhyper_eta = runif(20, 0, 1)\n\n\ntuning_results =\n    sapply(1:length(hyper_depth), function(k) {\n        auc_inner = NULL\n        for(j in 1:cv) {\n          inner_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n          train_inner = data_obs[inner_split != j, ]\n          test_inner = data_obs[inner_split == j, ]\n          \n          data_xg = xgb.DMatrix(data = as.matrix(train_inner[,-1]), label = train_inner$survived)\n          \n          model = xgboost(data_xg, nrounds = 16L, eta = hyper_eta[k], max_depth = hyper_depth[k], objective = \"reg:logistic\", verbose = 0)\n          predictions = predict(model, newdata = as.matrix(test_inner)[,-1])\n          \n          auc_inner[j]= Metrics::auc(test_inner$survived, predictions)\n        }\n      return(mean(auc_inner))\n    })\n\nresults = data.frame(depth = hyper_depth, eta = hyper_eta, AUC = tuning_results)\n\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   depth         eta       AUC\n1     49 0.988891729 0.8074158\n2     65 0.946668233 0.8049893\n3    153 0.082437558 0.8153178\n4     74 0.514211784 0.8146883\n5    146 0.390203467 0.8114173\n6    122 0.905738131 0.8061044\n7    200 0.446969628 0.8160412\n8    128 0.836004260 0.8098071\n9     47 0.737595618 0.8043019\n10    24 0.811055141 0.8043878\n11    71 0.388108283 0.8116825\n12   100 0.685169729 0.8073810\n13    89 0.003948339 0.8028995\n14   165 0.832916080 0.8080805\n15   110 0.007334147 0.8046759\n16    20 0.207658973 0.8166596\n17   154 0.906601408 0.8072941\n18   114 0.611778643 0.8088421\n19   111 0.379559241 0.8132467\n20   131 0.435771585 0.8126652\n```\n\n\n:::\n:::\n\n\n\n\nMake predictions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_xg = xgb.DMatrix(data = as.matrix(data_obs[,-1]), label = data_obs$survived)\n\nmodel = xgboost(data_xg, nrounds = 16L, eta = results[which.max(results$AUC), 2], max_depth = results[which.max(results$AUC), 1], objective = \"reg:logistic\")\n\npredictions = predict(model, newdata = as.matrix(data_new)[,-1])\n\n# Single predictions from the ensemble model:\nwrite.csv(data.frame(y = predictions), file = \"Max_titanic_xgboost.csv\")\n```\n:::\n\n\n\n\n\n</div>\n\n\n::: callout-warning\n#### Bonus: Implement a BRT on your own!\n\nYou can easily implement a BRT or boosted linear model using the rpart package or the lm function.\n:::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\nGo through the code line by line and try to understand it. Ask, if you have any questions:\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLet's try it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = model.matrix(~. , data = airquality)\n\nmodel = get_boosting_model(x = data[,-2], y = data[,2], n_trees = 5L )\npred = predict(model, newdata = data[,-2])\nplot(data[,2], pred, xlab = \"observed\", ylab = \"predicted\")\n```\n\n::: {.cell-output-display}\n![](B1-Trees_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n\n</div>\n\n\n\n\n:::: callout-warning\n#### Question: Hyperparameter tuning of random forest\n\n| Hyperparameter | Explanation |\n|-----------------|-------------------------------------------------------|\n| mtry | Subset of features randomly selected in each node (from which the algorithm can select the feature that will be used to split the data). |\n| minimum node size | Minimal number of observations allowed in a node (before the branching is canceled) |\n| max depth | Maximum number of tree depth |\n\nCombing back to the titanic dataset from the morning, we want to optimize min node size in our RF using a simple CV.\n\nPrepare the data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EcoData)\nlibrary(dplyr)\nlibrary(missRanger)\ndata(titanic_ml)\ndata = titanic_ml\ndata = \n  data %>% select(survived, sex, age, fare, pclass)\ndata[,-1] = missRanger(data[,-1], verbose = 0)\n\ndata_sub =\n  data %>%\n    mutate(age = scales::rescale(age, c(0, 1)),\n           fare = scales::rescale(fare, c(0, 1))) %>%\n    mutate(sex = as.integer(sex) - 1L,\n           pclass = as.integer(pclass - 1L))\ndata_new = data_sub[is.na(data_sub$survived),] # for which we want to make predictions at the end\ndata_obs = data_sub[!is.na(data_sub$survived),] # data with known response\ndata_sub$survived = as.factor(data_sub$survived)\ndata_obs$survived = as.factor(data_obs$survived)\n```\n:::\n\n\n\n\n**Hints:**\n\n-   adjust the '`type`' argument in the `predict(â€¦)` method (the default is to predict classes)\n-   when predicting probabilities, the randomForest will return a matrix, a column for each class, we are interested in the probability of surviving (so the second column)\n\n**Bonus:**\n\n-   tune min node size (and mtry)\n-   use more features\n\n::: {.callout-tip collapse=\"true\" appearance=\"minimal\"}\n## Code template\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ranger)\ndata_obs = data_sub[!is.na(data_sub$survived),] \nset.seed(42)\n\ncv = 3\nhyper_minnodesize = ...\n\ntuning_results =\n    sapply(1:length(hyper_minnodesize), function(k) {\n        auc_inner = NULL\n        for(j in 1:cv) {\n          inner_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n          train_inner = data_obs[inner_split != j, ]\n          test_inner = data_obs[inner_split == j, ]\n          \n          model = ranger(survived~.,data = train_inner, min.node.size = hyper_minnodesize[k], probability = TRUE)\n          predictions = predict(model, test_inner)$predictions[,2]\n          \n          auc_inner[j]= Metrics::auc(test_inner$survived, predictions)\n        }\n      return(mean(auc_inner))\n    })\n\nresults = data.frame(minnodesize = hyper_minnodesize, AUC = tuning_results)\n\nprint(results)\n```\n:::\n\n\n\n:::\n::::\n\n\n<div class='webex-solution'><button>Click here to see the solution</button>\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ranger)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'ranger'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:randomForest':\n\n    importance\n```\n\n\n:::\n\n```{.r .cell-code}\ndata_obs = data_sub[!is.na(data_sub$survived),] \nset.seed(42)\n\ncv = 3\nhyper_minnodesize = sample(300, 20)\n\ntuning_results =\n    sapply(1:length(hyper_minnodesize), function(k) {\n        auc_inner = NULL\n        for(j in 1:cv) {\n          inner_split = as.integer(cut(1:nrow(data_obs), breaks = cv))\n          train_inner = data_obs[inner_split != j, ]\n          test_inner = data_obs[inner_split == j, ]\n          model = ranger(survived~.,data = train_inner, min.node.size = hyper_minnodesize[k], probability = TRUE)\n          predictions = predict(model, test_inner)$predictions[,2]\n          \n          auc_inner[j]= Metrics::auc(test_inner$survived, predictions)\n        }\n      return(mean(auc_inner))\n    })\n\nresults = data.frame(minnodesize = hyper_minnodesize, AUC = tuning_results)\n\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   minnodesize       AUC\n1           49 0.8280246\n2          153 0.8188788\n3           74 0.8203274\n4          228 0.8143138\n5          146 0.8181020\n6          122 0.8193570\n7          300 0.8084306\n8          128 0.8213620\n9           24 0.8325978\n10          89 0.8216947\n11         165 0.8176674\n12         110 0.8197113\n13          20 0.8313352\n14         291 0.8087824\n15         283 0.8103171\n16         109 0.8216483\n17           5 0.8305181\n18         212 0.8127789\n19         259 0.8119109\n20         292 0.8081148\n```\n\n\n:::\n:::\n\n\n\n\nMake predictions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel = ranger(survived~.,data = data_obs, min.node.size = results[which.max(results$AUC),1], probability = TRUE)\n\nwrite.csv(data.frame(y = predict(model, data_new)$predictions[,1]), file = \"Max_titanic_rf.csv\")\n```\n:::\n\n\n\n\n\n</div>\n\n",
    "supporting": [
      "B1-Trees_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}